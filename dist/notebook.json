[{"nid":0,"notebook":"react","data":[{"title":"Update My Project With Immutable.js","time":"2016-12-10 10:06","notebook":"react","_key":11,"id":"20161210","html":"<h3 id=\"update-my-project-with-immutable-js\">Update My Project With Immutable.js</h3>\n<ul>\n<li>redux-immutable<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.\nAfter that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable. Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre>"},{"title":"React单页面应用项目 性能优化 实践","time":"2016-07-19 13:54:58","notebook":"react","_key":7,"id":"20160719","html":"<h1 id=\"react-\">React单页面应用项目 性能优化 实践</h1>\n<p>react 单页面应用项目在加载优化这一块就得依赖webpack的打包方式。\nwebpack的打包优化的本质就是将 bundle.js 拆分方式进行优化。</p>\n<p>目前，就我所知的 bundle.js 的拆分方式有以下几种</p>\n<blockquote>\n<ul>\n<li>按需加载\n这个方式要求在react-router中不能简单的import container，需要用到requier.ensure()方法，具体实践可以参阅相关文档，如果不用require.ensure()，webpack将不会生成很多个chunkfile，也不能实现将 bundle.js 优化的效果。下面是配置代码。</li>\n</ul>\n</blockquote>\n<pre><code>entry: {\n    main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)]\n},\noutput: {\n    path: path.resolve(__dirname, &quot;dist/app&quot;),\n    filename: &#39;bundle.[hash].js&#39;,\n    chunkFilename: &#39;[id].[hash].chunk.js&#39;,\n    publicPath: &#39;/dist/app/&#39;\n}\n</code></pre><blockquote>\n<ul>\n<li>利用webpack插件进行提取一部分内容以压缩 bundle.js\n这个方法具体用到的插件有 ExtractTextPlugin，CommonsChunkPlugin。\n同时在nginx配置中开启gzip。\n下面是配置代码</li>\n</ul>\n</blockquote>\n<pre><code>    entry: {\n      main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)],\n      vendor:[&#39;react&#39;, &#39;redux&#39;] // 将一些比较大的库单独提取出来。\n    },\n    output: {\n        path: path.resolve(__dirname, &quot;dist/app&quot;),\n        filename: &#39;bundle.[hash].js&#39; // 只生成单个bundle.js文件\n    },\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n                warnings: false\n            }\n        }),\n        new ExtractTextPlugin(&#39;[name]-[chunkhash].css&#39;, {allChunks: true}), //用该插件提取所有css样式\n        new webpack.optimize.CommonsChunkPlugin(&#39;vendor&#39;,  &#39;vendor.js&#39;), //将那些库生成 vendor.js\n    ],\n    module: {\n        loaders: [\n            {\n                test: /\\.scss$/,\n                loader: ExtractTextPlugin.extract(&#39;style&#39;,&#39;css?modules&amp;importLoaders=2&amp;sourceMap&amp;localIdentName=[local]___[hash:base64:5]!sass?outputStyle=expanded&amp;sourceMap&#39;)\n            } // 将scss生成的css样式单独提取出来\n        ]\n    },\n</code></pre><blockquote>\n<ul>\n<li>还有就是上面两者的混合配置</li>\n</ul>\n</blockquote>\n<h3 id=\"-\">下面将上述的三种配置进行性能测试</h3>\n<blockquote>\n<p>测试用的是chrome的timeline，并且将项目的各项数据记录了下来</p>\n</blockquote>\n<ol>\n<li>按需加载</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_0.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>提取公共部分与css</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_1.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>混合模式</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_2.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>其实不难看出大部分的时间差异是在scripting和ldle，其他的差异都是几十毫秒而已，二这两项的差异能达到上百毫秒。</p>\n</blockquote>\n<h1 id=\"-\">总结</h1>\n<blockquote>\n<p>最后我对于项目采用何种优化方式进行一下自己的体验和总结。</p>\n<ol>\n<li>如果是小项目 bundle.js 比较小，建议使用提取公共部分与css就行。</li>\n<li>如果是大项目 bundle.js 比较大，建议使用混合模式想方设法减小bundle.js单个文件的大小。</li>\n<li>建议用sass或者less写样式，不使用内联写法，因为最后可以提取出来单独成为css。而内联写法就只能存在于bundle.js之中，增大了bundle.js。</li>\n<li>使用nginx配置，并且开启gzip。</li>\n</ol>\n</blockquote>\n"},{"title":"react modal 的 简单实现 与 原理分析","time":"2016-06-29 16:31:30","notebook":"react","_key":5,"id":"20160629","html":"<h1 id=\"react-modal-\">react modal 的 简单实现 与 原理分析</h1>\n<blockquote>\n<p>在React项目中，由于所有的Component将会被render在body的一个div之中，并且往往是Component包Component，就像一个洋葱一样，一层包着一层，里层的很难触及比较外面的一层。</p>\n<p>可是，在css中，position属性往往被外层的position所左右，height: 100% 往往被外层的height所左右。如何才能做出一个拥有半透明的黑色遮罩，罩住整个页面，从而实现modal的效果呢？</p>\n</blockquote>\n<p>在react 中，modal 的思路就是制作一个<strong><Modal></Modal></strong> Component，但是把它render 到body 的下一层去，而不是跟其他Component 一样render 到Component 的最里层。</p>\n<p>只有render在body的下一层，与现有的Component 组平起平坐，这样才完全脱离的样式局限，当我在<strong><Modal></Modal></strong> 设置样式的时候可以为所欲为。</p>\n<p>在这里就要借助 <strong>react-dom</strong> 了。因为render方法是 <strong>react-dom</strong> 提供的；\n下面将是我测试的代码。</p>\n<pre><code>import React, {Component, PropTypes} from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\n\nexport default class Modal extends Component {\n    static defaultProps = {\n        open: false\n    };\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.open &amp;&amp; !this.props.open) { // 从无到有\n            this.node = document.createElement(&#39;div&#39;); // 创建 DOM\n            this.node.className = &#39;ReactModal&#39;; // 给上 ClassName\n            document.getElementsByTagName(&#39;body&#39;)[0].appendChild(this.node) // 给 body 加上刚才的 带有 className 的 div\n            // 这个时候创建了 render的目的地。\n            const style = require(&#39;./style.scss&#39;); // css 样式\n            const {children, ...rest} = nextProps;\n            let modal = (\n                &lt;div className={style.container}&gt;\n                    &lt;div className={style.mask} {...rest}&gt;&lt;/div&gt;\n                    {nextProps.children}\n                &lt;/div&gt;\n            );\n            // 这个时候创建了 Modal 的虚拟 Dom\n            let allClass = document.getElementsByClassName(&#39;ReactModal&#39;);\n            ReactDOM.render(modal, allClass[allClass.length - 1]) // 之所以这么写，是因为能重复打开Modal，因为每一次打开Modal，都会建立一个div\n            // 将 Modal 成功 render 到目的地\n        }\n        if (this.props.open &amp;&amp; !nextProps.open) { // 从有到无\n            ReactDOM.unmountComponentAtNode(this.node) // 调用 react-dom unmountComponentAtNode方法，将Modal解除。\n            // 或者可以写下面的方法，将整个创建的div删除，这样多次打开就不会有很多个div残留在body中，但是并不是很正规的做法。\n            // document.getElementsByTagName(&#39;body&#39;)[0].removeChild(document.getElementsByClassName(&#39;ReactModal&#39;)[0])\n        }\n    }\n    render() {\n        return null // 只要这个Component的方法，不要它的render，它的render将会render到内层。\n    }\n}\n</code></pre><p><img src=\"http://api.jasonff.top/dist/20160629_0.png\" alt=\"Paste_Image.png\"></p>\n<p>选中处为刚添加的dom，它被正确的render到body下一层，与<strong> #content </strong>平起平坐，里面有内容，上面的div为多次打开关闭Modal之后残留的div。</p>\n"},{"title":"react server rendering","time":"2016-05-25 17:05:30","notebook":"react","_key":1,"id":"20160525","html":"<h1 id=\"react-server-rendering-\">react server rendering（服务端渲染）</h1>\n<p><em>一个react项目在服务器端渲染，其实最本质的一个点就在于路由。路由一般采用的是<code>react-router</code>。其实在<code>react-router</code>里，它本身就提供了服务器端渲染的方法，下面对它进行一下小小的学习。</em></p>\n<p>服务端渲染跟客户端渲染有点不同，因为，服务端渲染需要发送500/30x，还要在渲染前就要请求数据。</p>\n<p><code>react-router</code>提供了两个更底层的api，一个是<code>match</code>，另一个是<code>RouterContext</code>。</p>\n<p><code>match</code>是用来匹配路由的，但是它没有渲染的功能。\n<code>RouterContext</code>用来同步渲染components的。</p>\n<p>看个例子：</p>\n<pre><code>import { renderToString } from &#39;react-dom/server&#39;\nimport { match, RouterContext } from &#39;react-router&#39;\nimport routes from &#39;./routes&#39;\nserve((req, res) =&gt; {\n    match({ routes, location: req.url }, (error, redirectLocation, renderProps) =&gt; {\n        if (error) {\n            res.status(500).send(error.message)\n        } else if (redirectLocation) {\n            res.redirect(302, redirectLocation.pathname + redirectLocation.search)\n        } else if (renderProps) {\n            res.status(200).send(renderToString(&lt;RouterContext {...renderProps} /&gt;))\n        } else {\n            res.status(404).send(&#39;Not found&#39;)\n        }\n    })\n})\n</code></pre><p>这是一个非常简单的在服务端渲染例子，但是现在一个最重要的问题，就是如何传数据呢？</p>\n<p>在react项目中，一般是用redux来进行数据的管理的。redux 里有个store维护的state状态树。那么在和api进行数据交互的时候，如何将数据放在store里面呢？</p>\n<p>基本的思路就是，在createStore的时候，将与api交互的方法同时传入进去，这样，在store中的action可以调用那个库。调用库去请求数据，一般是个promise对象，取到数据之后，然后在reducer中将数据reduce进state树中。就完成了这个过程。</p>\n<p>其实最最本质的，就是让action能去api请求数据，只要action请求到了数据并且能进入reducer，那就成功了。这个思路跟客户端渲染也没有什么区别。</p>\n<p>在服务端渲染还有一个致命的报错。来自于webpack。</p>\n<p>在client，webpack可以require()各种静态资源，但是在node 环境中,require()是只能用于javascript 的。</p>\n<p>这里就要靠一个library了。\n<a href=\"https://github.com/halt-hammerzeit/webpack-isomorphic-tools\">webpack-isomorphic-tools</a>\n具体的介绍在github中都有，也不在这里赘述。</p>\n<p>另外再向大家推荐一个完整的react例子，里面有很多很多东西可以参考借鉴，甚至可以直接拿过来做自己的项目。\n<a href=\"https://github.com/erikras/react-redux-universal-hot-example\">react栗子</a></p>\n"},{"title":"react-router 笔记","time":"2016-05-11 17:16:30","notebook":"react","_key":0,"id":"20160511","html":"<h1 id=\"react-router-\">react-router 笔记</h1>\n<h4 id=\"-hashhistory-\"><strong><code>hashHistory</code>什么用？</strong></h4>\n<p>它控制着带着hash值的路由，比如说有两个路由</p>\n<pre><code>  &lt;Router history={hashHistory}&gt;\n    &lt;Route path=&quot;/&quot; component={App}/&gt;\n    {/* add the routes here */}\n    &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n    &lt;Route path=&quot;/about&quot; component={About}/&gt;\n  &lt;/Router&gt;\n</code></pre><p>现在去访问的话通过hash值比如\n<code>localhost:8080/#/about</code>\n<code>localhost:8080/#/repos</code>\n那我不想出现那个#呢？\n那就用<code>browserHistory</code></p>\n<h4 id=\"-link-a-\"><strong> Link 和 a 标签的区别</strong></h4>\n<p>其中一个区别是标记active。这个在导航的时候特别管用。\n以往，想要标记active需要操作dom给导航添加class或者style。\n<code>Link</code>标签提供了两个接口 <code>activeStyle</code> 和 <code>activeClassName</code> 在<code>Link</code> active的时候自动变换样式。\n<code>Link</code> 是 <code>react-router</code>内部的跳转，<code>a</code> 是浏览器的跳转。</p>\n<h4 id=\"-\"><strong>组件传参的技巧</strong></h4>\n<p>以前在传参数的时候，总会在组件中定义一些东西，比如<code>handleChange</code>、<code>handleClick</code>啊什么的。甚至在拿数据的时候还传了<code>handleRef</code>。\n现在经过观看别人的项目，我发现几个更好的解决方案。\n第一个，如何传一些<code>onChange</code>什么的参数。很简单，<code>{...this.props}</code>然后在父级的时候，传<code>onChange()</code>。传什么就进来什么，每个组件的可定义度很高。\n第二个，如何传<code>input</code>中的数据，用<code>event</code>，在<code>onChange</code>事件中，可以传<code>event</code>，然后通过<code>event.target</code>来获取<code>input</code>的DOM。so easy!</p>\n<h4 id=\"-url-\"><strong> 关于url中传参的问题</strong></h4>\n<p>比如，我想打开</p>\n<pre><code>/repos/reactjs/react-router\n/repos/facebook/react\n</code></pre><p>怎么整？\n它其实在url中传了两个参数，我们暂且定义成这样</p>\n<pre><code>/repos/:userName/:repoName\n</code></pre><p>第一、路由怎么写？</p>\n<pre><code> &lt;Route path=&quot;/repos/:userName/:repoName&quot; component={Repo}/&gt;\n</code></pre><p>第二、Link怎么写？</p>\n<pre><code> &lt;Link to=&quot;/repos/reactjs/react-router&quot;&gt;React Router&lt;/Link&gt;\n</code></pre><p>第三、如何在页面中取到参数？</p>\n<pre><code> &lt;h2&gt;{this.props.params.repoName}&lt;/h2&gt;\n</code></pre><p>这个其实还挺简单的。</p>\n<h4 id=\"-js-\"><strong>关于用js来实现页面路由跳转问题</strong></h4>\n<p>在react-router中，据我所知，有两种方法。\n第一种，使用withRouter()，然后将在内部可以获取this.props.router。\n第二种，使用this.context.router，不过在使用前必须定义这个类的contextTypes。</p>\n<p>withRouter怎么用？</p>\n<pre><code> ...\n import {withRouter} from &#39;react-router&#39;\n class Abc extends Component {\n                  ...\n       this.props.router.push(&#39;/&#39;)\n}\nexport default withRouter(Abc)\n</code></pre><p>用context怎么用？</p>\n<pre><code> ...\nexport default class Abc extends Component {\n                  ...\n       this.context.router.push(&#39;/&#39;)\n}\nAbc.contextTypes = {\n       router: React.PropsTypes.object\n}\n</code></pre>"}]},{"nid":1,"notebook":"javascript","data":[{"title":"javascript some tips","time":"2016-12-07 10:15","notebook":"javascript","_key":10,"id":"20161207","html":"<h1 id=\"some-tips\">some tips</h1>\n<p><em>some tips about javascript</em></p>\n<hr>\n<h3 id=\"what-is-the-difference-between-map-every-and-foreach-\">What is the difference between .map, .every, and .forEach?</h3>\n<ul>\n<li><p>.map()</p>\n<blockquote>\n<p>returns a new Array of objects created by taking some action on the original item.</p>\n</blockquote>\n</li>\n<li><p>.every()</p>\n<blockquote>\n<p>returns a boolean - true if every element in this array satisfies the provided testing function. An important difference with .every() is that the test function may not always be called for every element in the array. Once the testing function returns false for any element, no more array elements are iterated. Therefore, the testing function should usually have no side effects.</p>\n</blockquote>\n</li>\n<li><p>.forEach()</p>\n<blockquote>\n<p>returns nothing - It iterates the Array performing a given action for each item in the Array.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"the-test-about-immutable-js\">the test about Immutable.js</h3>\n<blockquote>\n<p>It is not a very good way to add Immutable.js into a part of project.</p>\n</blockquote>\n<ul>\n<li>redux-immutable<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.\nAfter that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable. Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre><hr>\n"}]},{"nid":2,"notebook":"node","data":[{"title":"JasonFF 静态博客的一些总结","time":"2016-11-28 20:54:12","notebook":"node","_key":9,"id":"20161127","html":"<h1 id=\"jasonff-\">JasonFF 静态博客的一些总结</h1>\n<h2 id=\"-markdown-json-\">一、将 markdown 编译为json格式</h2>\n<pre><code>var fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\nvar marked = require(&#39;marked&#39;);\nvar request = require(&#39;request&#39;);\nvar downloadPic = require(&#39;./widgets/downloadPic&#39;);\n\nfunction MarkdownReader(options) {\n    this.from = options.from;\n    this.to = options.to;\n    this.rule = /\\.md$/;\n}\n\nMarkdownReader.prototype.apply = function() {\n    var that = this;\n    try {\n        fs.readdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    } catch (e) {\n        fs.mkdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    }\n\n    fs.readdir(that.from, function(error, files) {\n        if (error) {\n            console.error(error)\n        }\n        var mddata = new Array();\n        var notebook = new Array();\n\n        for (var i = 0; i &lt; files.length; i++) {\n            if (that.rule.test(files[i])) {\n                var article;\n                try {\n                    article = that._getArticle(files[i], i);\n                    mddata.push(article)\n                } catch (e) {\n                    console.log(e)\n                }\n\n            }\n        }\n        fs.writeFileSync(path.join(that.to, &#39;data.json&#39;), JSON.stringify(mddata.reverse()))\n        fs.writeFileSync(path.join(that.to, &#39;notebook.json&#39;), JSON.stringify(that._getNotebook(mddata)))\n    })\n}\n\n\nMarkdownReader.prototype._getArticle = function(files, index) {\n    var that = this;\n    var fileInfo;\n    var _path = path.join(that.from, files);\n    var fileText = fs.readFileSync(path.join(that.from, files)).toString()\n    var configText = fileText.substring(0, fileText.indexOf(&#39;}&#39;) + 1)\n    var markdownText = fileText.substring(fileText.indexOf(&#39;}&#39;) + 1);\n    var markdownText = this._getPic(markdownText,files)\n    var fileInfo = fs.statSync(_path)\n\n    try {\n        var config = JSON.parse(configText)\n    } catch (e) {\n        console.error(e);\n    }\n    if (!config) {\n        console.error(files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot;)\n        console.log(&quot;请在 &quot; + files + &quot; 开头添加JSON格式的信息！参照栗子！请注意JSON的语法！请不要在JSON中写对象！！&quot;)\n        console.log(&quot;你看看你写的什么 &quot; + configText)\n        return false\n    }\n    config._key = index;\n    config.id = files.replace(&#39;.md&#39;, &#39;&#39;);\n    var markdownHTML = marked(markdownText);\n    config.html = markdownHTML;\n\n    return config\n}\n\nMarkdownReader.prototype._getNotebook = function(config) {\n    var result = new Array();\n    var nid = 0;\n    for (var i = 0; i &lt; config.length; i++) {\n        for (var m = 0; m &lt; result.length; m++) {\n            var ifMatch = false;\n            if (result[m].notebook == config[i].notebook) {\n                result[m].data.push(config[i]);\n                ifMatch = true;\n                break\n            }\n        }\n        if (!ifMatch) {\n            result.push({\n                nid: nid,\n                notebook: config[i].notebook,\n                data: [config[i]]\n            })\n            nid++\n        }\n    }\n    return result;\n}\n\nMarkdownReader.prototype._getPic = function(md,filename) {\n    var result,urls;\n    var _md = md;\n    try {\n        result = _md.match(/\\!\\[[^\\]]+\\]\\([^\\)]+\\)/ig)\n    } catch (e) {}\n    if (result) {\n        urls = result.map(function(item,i){\n            return /\\([^\\)]+\\)/ig.exec(item)[0].replace(/^\\(/,&#39;&#39;).replace(/\\)$/,&#39;&#39;)\n        })\n    }\n    if (urls) {\n        var basePath = path.join(__rootPath,&#39;/dist&#39;);\n        for (var i = 0; i &lt; urls.length; i++) {\n            var imgName = filename.replace(&#39;.md&#39;,&#39;&#39;)+&#39;_&#39;+i+&#39;.png&#39;;\n            downloadPic(urls[i],basePath,imgName)\n            _md = _md.replace(urls[i],&#39;http://api.jasonff.top/dist/&#39;+imgName)\n        }\n    }\n    return _md\n}\n\nmodule.exports = MarkdownReader;\n</code></pre><ul>\n<li>图片插入的解决方案\n如果按照markdown的语法进入插入图片，显得太麻烦了，人活着就是为了偷懒，怎么样才能快速将图片插入我的markdown文档中呢？\n我发现简书的插入图片特别的方便，直接在编辑器中粘贴就把图片给插入进去了。但是我的编辑环境是atom 啊。难不成自己写个atom插件？\natom插件貌似也是可行的。但是我发现一个特别偷懒的办法，我不是可以获取简书的图片地址吗？我可以把图片借助简书给下到指定文件夹。\n下面就是代码</li>\n</ul>\n<pre><code>var path = require(&#39;path&#39;);\nvar request = require(&#39;request&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar download = function(uri, dir,filename){\n    console.log(&#39;start+++&#39;+uri)\n    request.head(uri, function(err, res, body){\n        request(uri).pipe(fs.createWriteStream(dir + &quot;/&quot; + filename));\n    });\n};\n\nmodule.exports = download;\n</code></pre><blockquote>\n<p>这个就是写的下载图片到本地文件夹的一个方法。插入到markdown文件中已经在最上面的代码中体现。</p>\n</blockquote>\n<h2 id=\"-nginx-\">二、nginx 静态代理</h2>\n<p>这个时候，我已经把markdown文档转为了json格式，并且进行了编译。我把图片也已经下载到了指定的文件夹。我现在就需要将这些资源给送出去给我的前端web app。这里用依靠nginx啦！</p>\n<pre><code>server {\n    listen       80;\n    server_name  api.jasonff.top 127.0.0.1;\n\n    root /home/ubuntu/github/jasonff-api;\n\n    gzip on;\n    location ~ \\.json$ {\n        if ($request_method = &#39;OPTIONS&#39;) {\n            add_header Access-Control-Allow-Origin *;\n            add_header Access-Control-Allow-Credentials true;\n            add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n            return 200;\n        }\n\n        if ($request_method = &#39;POST&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n\n        if ($request_method = &#39;GET&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n    }\n\n}\n</code></pre><h2 id=\"-\">三、博客前端部分</h2>\n<blockquote>\n<p>前端部分没什么好说的，主要是react的一些东西。有关于react的总结，我将会有另外的笔记。</p>\n</blockquote>\n"},{"title":"微信JS-SDK(express 实践)","time":"2016-06-01 15:48:30","notebook":"node","_key":2,"id":"20160601","html":"<h1 id=\"-js-sdk-express-\">微信JS-SDK(express 实践)</h1>\n<p>在这里我记录一下用node express配置微信开发的一些代码</p>\n<p>简单的三个页面</p>\n<pre><code>app.use(&#39;/&#39;, routes);\napp.use(&#39;/users&#39;, users);\napp.use(&#39;/login&#39;, login);\n</code></pre><h3 id=\"routes\">routes</h3>\n<p>这个页面我做的是 <strong>用户同意授权，获取code</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\n/* GET home page. */\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var redirect_uri = &quot;http%3A%2F%2Fwww.frombottomto.top/login&quot;;\n    var scope = &#39;snsapi_userinfo&#39;;//两种方式\n    var state = &#39;STATE&#39;;//非必须\n\n    var url = &#39;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#39;+appid+&#39;&amp;redirect_uri=&#39;+redirect_uri+&#39;&amp;response_type=code&amp;scope=&#39;+scope+&#39;&amp;state=&#39;+state+&#39;#wechat_redirect&#39;;\n    res.redirect(url);\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"login\">login</h3>\n<p>这个页面获取的是 <strong>拉取用户信息</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var code = req.query.code;\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var url = &#39;https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#39;+appid+&#39;&amp;secret=6841a50bd9b6e99c77d0e052e5e5eb2a&amp;code=&#39;+code+&#39;&amp;grant_type=authorization_code&#39;;\n\n    //获取code后，请求以下链接获取access_token：  https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code\n    //获取json后get: https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN\n\n    fetch(url).then(function(res){\n        return res.json()\n    }).then(function(json){\n        var accesstoken = json.access_token;\n        var openid = json.openid;\n        var tokenurl = &#39;https://api.weixin.qq.com/sns/userinfo?access_token=&#39;+accesstoken+&#39;&amp;openid=&#39;+openid+&#39;&amp;lang=zh_CN &#39;;\n        return fetch(tokenurl).then(function(res){\n            return res.json()\n        })\n    }).then(function(json){\n        res.send(json)\n    })\n\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"users\">users</h3>\n<p>这个页面获取的是<strong> JS-SDK的 signature</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\nvar sha1 = require(&#39;sha1&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var aturl = &#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#39;+appid+&#39;&amp;secret=&#39;+secret;\n    var access_token;\n\n    fetch(aturl).then(function(res){\n        return res.json()\n    }).then(function(json){\n        access_token = json.access_token;\n        var ticketurl = &#39;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&#39;+access_token+&#39;&amp;type=jsapi&#39;\n        //https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi\n\n        var jsticket;\n        fetch(ticketurl).then(function(res){\n            return res.json()\n        }).then(function(json){\n            jsticket = json.ticket;\n            console.log(req.originalUrl)\n            var string1 = &#39;jsapi_ticket=&#39;+jsticket+&#39;&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://www.frombottomto.top&#39;+req.originalUrl;\n            var signature = sha1(string1);\n            res.render(&#39;users&#39;,{signature:signature})\n        })\n\n    })\n    //https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\n});\n\nmodule.exports = router;\n</code></pre><p>另外前端渲染页面，记录的是调取微信api</p>\n<h3 id=\"users-ejs\">users.ejs</h3>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;微信js测试&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;link rel=&#39;stylesheet&#39; href=&#39;/stylesheets/style.css&#39; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;你好&lt;/h1&gt;\n    &lt;p&gt;Welcome to 微信&lt;/p&gt;\n    &lt;img src=&quot;/image/jf.png&quot; alt=&quot;&quot;&gt;\n    &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        wx.config({\n            debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n            appId: &#39;wx9bf16c912ddec096&#39;, // 必填，公众号的唯一标识\n            timestamp: 1414587457, // 必填，生成签名的时间戳\n            nonceStr: &#39;Wm3WZYTPz0wzccnW&#39;, // 必填，生成签名的随机串\n            signature: &#39;&lt;%= signature %&gt;&#39;,// 必填，签名，见附录1\n            jsApiList: [&#39;onMenuShareTimeline&#39;,&#39;onMenuShareAppMessage&#39;] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2\n        });\n        wx.ready(function(){\n            wx.onMenuShareTimeline({\n                title: &#39;JasonFF&#39;, // 分享标题\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n            wx.onMenuShareAppMessage({\n                title: &#39;JasonFF&#39;, // 分享标题\n                desc: &#39;JasonFF的主页&#39;, // 分享描述\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                type: &#39;link&#39;, // 分享类型,music、video或link，不填默认为link\n                dataUrl: &#39;&#39;, // 如果type是music或video，则要提供数据链接，默认为空\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n        })\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"}]},{"nid":3,"notebook":"服务器","data":[{"title":"linux 虚拟内存实践","time":"2016-11-16 21:41:58","notebook":"服务器","_key":8,"id":"20161116","html":"<h1 id=\"linux-\">linux 虚拟内存实践</h1>\n<ul>\n<li><p>查看 Swap 大小</p>\n<pre><code>free -m\n</code></pre></li>\n<li><p>创建一个 Swap 文件</p>\n<pre><code>mkdir swap\ncd swap\nsudo dd if=/dev/zero of=swapfile bs=1024 count=100000\n</code></pre><blockquote>\n<p>count 代表文件的大小</p>\n</blockquote>\n</li>\n<li><p>把生成的文件转换成 Swap 文件</p>\n<pre><code>sudo mkswap swapfile\n</code></pre></li>\n<li><p>激活 Swap 文件</p>\n<pre><code>sudo swapon swapfile\n</code></pre><blockquote>\n<p>再次查看 free -m 发现添加成功了</p>\n</blockquote>\n</li>\n<li><p>卸载 Swap</p>\n<pre><code>sudo swapoff swapfile\n</code></pre><blockquote>\n<p>进入刚才那个目录</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"React 静态页面 nginx 配置 小白专用","time":"2016-06-15 20:50:30","notebook":"服务器","_key":3,"id":"20160615","html":"<h1 id=\"react-nginx-\">React 静态页面 nginx 配置 小白专用</h1>\n<h3 id=\"-\">第一步：安装</h3>\n<ol>\n<li><a href=\"http://nginx.org/en/download.html\">http://nginx.org/en/download.html</a> 下载</li>\n<li><code>tar -xf nginx-1.2.0.tar.gz</code></li>\n<li>进入解压目录  <code>chmod a+rwx *</code></li>\n<li><code>./configure --without-http_rewrite_module</code></li>\n<li><code>make &amp;&amp; make install</code></li>\n<li><code>sudo /usr/local/nginx/sbin/nginx</code></li>\n<li>浏览器访问 localhost</li>\n<li>惊奇地发现欢迎页面</li>\n</ol>\n<h3 id=\"-\">第二步：基本操作</h3>\n<ul>\n<li>启动<pre><code>cd /usr/local/nginx/sbin\n./nginx\n</code></pre></li>\n<li>软链接\n启动那么麻烦，我想直接打nginx启动！<pre><code>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx\n</code></pre></li>\n<li>查看启动的配置文件\n<code>sudo nginx -t</code></li>\n<li>重启\n<code>sudo nginx -s reload</code></li>\n<li>关闭<pre><code>ps -ef | grep nginx\nkill -QUIT xxxx\n</code></pre></li>\n</ul>\n<h2 id=\"-react-nginx-\">第三步 React 静态页面 nginx 配置 简洁版</h2>\n<pre><code>worker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       8080;\n        server_name  localhost;\n\n        root /Users/jasonff/project/erp-web;\n\n        location / {\n            try_files $uri @fallback;\n        }\n\n        location @fallback {\n            rewrite .* /index.html break;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n    include servers/*;\n}\n</code></pre><h3 id=\"-\">若干解释：</h3>\n<ul>\n<li>我的配置文件在哪里？\n想知道自己的配置文件在哪里，查看第二步中的查看启动配置文件，然后将需要的配置写在这个文件里面。</li>\n</ul>\n<h2 id=\"-\">第四步：多个站点布置</h2>\n<p>在nginx.conf 文件所在目录中，新建一个文件夹 vhost ，新建若干个文件，例如 example1.conf 、 example2.conf ……</p>\n<pre><code>server {\n    listen       8030;\n    server_name  localhost;\n    root /Users/jasonff/project/souban-website;\n    location / {\n        try_files $uri @fallback;\n    }\n    location @fallback {\n        rewrite .* /index.html break;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n}\n</code></pre><p>然后重新配置nginx.conf</p>\n<pre><code>worker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    include        vhosts/*;\n    //加入include vhosts/*\n}\n</code></pre><h3 id=\"-\">附录：配置介绍（字典查询）</h3>\n<pre><code>#运行用户\nuser nobody;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes  1;\n\n#全局错误日志及PID文件\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n#工作模式及连接数上限\nevents {\n    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,\n    #仅用于linux2.6以上内核,可以大大提高nginx的性能\n    use   epoll;\n\n    #单个后台worker process进程的最大并发链接数    \n    worker_connections  1024;\n\n    # 并发总数是 worker_processes 和 worker_connections 的乘积\n    # 即 max_clients = worker_processes * worker_connections\n    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么\n    # 为什么上面反向代理要除以4，应该说是一个经验值\n    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000\n    # worker_connections 值的设置跟物理内存大小有关\n    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数\n    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右\n    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：\n    # $ cat /proc/sys/fs/file-max\n    # 输出 34336\n    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内\n    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置\n    # 使得并发总数小于操作系统可以打开的最大文件数目\n    # 其实质也就是根据主机的物理CPU和内存进行配置\n    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。\n    # ulimit -SHn 65535\n\n}\n\n\nhttp {\n    #设定mime类型,类型由mime.type文件定义\n    include    mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  logs/access.log  main;\n\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\n    #对于普通应用，必须设为 on,\n    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\n    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n    sendfile     on;\n    #tcp_nopush     on;\n\n    #连接超时时间\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    tcp_nodelay     on;\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6].&quot;;\n\n    #设定请求缓冲\n    client_header_buffer_size    128k;\n    large_client_header_buffers  4 128k;\n\n\n    #设定虚拟主机配置\n    server {\n        #侦听80端口\n        listen    80;\n        #定义使用 www.nginx.cn访问\n        server_name  www.nginx.cn;\n\n        #定义服务器的默认网站根目录位置\n        root html;\n\n        #设定本虚拟主机的访问日志\n        access_log  logs/nginx.access.log  main;\n\n        #默认请求\n        location / {\n\n            #定义首页索引文件的名称\n            index index.php index.html index.htm;  \n\n        }\n\n        # 定义错误提示页面\n        error_page   500 502 503 504 /50x.html;\n        location = /50x.html {\n        }\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n\n            #过期30天，静态文件不怎么更新，过期可以设大一点，\n            #如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        }\n\n        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\n        location ~ .php$ {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n            include fastcgi_params;\n        }\n\n        #禁止访问 .htxxx 文件\n            location ~ /.ht {\n            deny all;\n        }\n\n    }\n}\n</code></pre><p>附上我的图片</p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_0.png\" alt=\"Paste_Image.png\"></p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_1.png\" alt=\"Paste_Image.png\"></p>\n"}]},{"nid":4,"notebook":"html&css","data":[{"title":"css3 转盘抽奖实践(sass)","time":"2016-07-07 20:29:58","notebook":"html&css","_key":6,"id":"20160707","html":"<h1 id=\"css3-sass-\">css3 转盘抽奖实践(sass)</h1>\n<blockquote>\n<p>转盘抽奖，就是像这样子的转盘。（如下图）\n点击中间的“点击抽奖”按钮，然后后面的圆形转盘开始转动，最后停在所在结果里。</p>\n</blockquote>\n<p><img src=\"http://api.jasonff.top/dist/20160707_0.png\" alt=\"Paste_Image.png\"></p>\n<h2 id=\"-\">如何实现旋转并且让指针指向目标区域？</h2>\n<blockquote>\n<p>我这里的思路是用css3的一些功能，为了能够写的便捷，我用了sass工具进行编译。</p>\n</blockquote>\n<pre><code>\n$get1: - (120deg+180deg)/2 + 5400deg;\n$get2: - (225deg+180deg)/2 + 5400deg;\n$get5: - (225deg+270deg)/2 + 5400deg;\n$get10: - (45deg+90deg)/2 + 5400deg;\n$get20: - (0deg+45deg)/2 + 5400deg;\n$get50: - (360deg+334deg)/2 + 5400deg;\n$get100: - (308deg+334deg)/2 + 5400deg;\n\n// 这里的角度，都是转盘图片中，各个区域的角度，最终将指针指向每个扇形的中心。\n// 5400deg 是转的圈数\n\n$timing: cubic-bezier(0,0,0,1);\n\n@mixin transformRotate($deg) {\n  transform:rotate($deg);\n  -ms-transform:rotate($deg); /* Internet Explorer */\n  -moz-transform:rotate($deg); /* Firefox */\n  -webkit-transform:rotate($deg); /* Safari 和 Chrome */\n  -o-transform:rotate($deg); /* Opera */\n}\n@mixin getAnimation($attribute) {\n  animation: #{$attribute};\n  -moz-animation: #{$attribute};    /* Firefox */\n  -webkit-animation: #{$attribute};    /* Safari 和 Chrome */\n  -o-animation: #{$attribute};    /* Opera */\n}\n\n@mixin keyframes($animationname, $get) {\n  @keyframes #{$animationname}\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-moz-keyframes #{$animationname} /* Firefox */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-webkit-keyframes #{$animationname} /* Safari 和 Chrome */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-o-keyframes #{$animationname} /* Opera */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n}\n\n@include keyframes(Kget1, $get1);\n@include keyframes(Kget2, $get2);\n@include keyframes(Kget5, $get5);\n@include keyframes(Kget10, $get10);\n@include keyframes(Kget20, $get20);\n@include keyframes(Kget50, $get50);\n@include keyframes(Kget100, $get100);\n\n.get1 {\n  @include getAnimation(&#39;Kget1 10s #{$timing} forwards&#39;);\n}\n// forwards 属性是为了在动画结束的时候不再跳回初始的状态\n.get2 {\n  @include getAnimation(&#39;Kget2 10s #{$timing} forwards&#39;);\n}\n.get5 {\n  @include getAnimation(&#39;Kget5 10s #{$timing} forwards&#39;);\n}\n.get10 {\n  @include getAnimation(&#39;Kget10 10s #{$timing} forwards&#39;);\n}\n.get20 {\n  @include getAnimation(&#39;Kget20 10s #{$timing} forwards&#39;);\n}\n.get50 {\n  @include getAnimation(&#39;Kget50 10s #{$timing} forwards&#39;);\n}\n.get100 {\n  @include getAnimation(&#39;Kget100 10s #{$timing} forwards&#39;);\n}\n</code></pre><h2 id=\"-cubic-bezier-\">下面主要对 cubic-bezier 属性进行一些注释</h2>\n<p><img src=\"http://api.jasonff.top/dist/20160707_1.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>cubic-bezier即为贝兹曲线中的绘制方法。图上有四点，P0-3，其中P0、P3是默认的点，对应了[0,0], [1,1]。而剩下的P1、P2两点则是我们通过cubic-bezier()自定义的。cubic-bezier(x1, y1, x2, y2) 为自定义，x1,x2,y1,y2的值范围在[0, 1]。\n    预留的几个特效：\n    ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)\n    linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)\n    ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)\n    ease-out: cubic-bezier(0, 0, 0.58, 1.0)\n    ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)\n也就是说第四个n是y2，和x2共同决定P2的位置</p>\n</blockquote>\n"}]},{"nid":5,"notebook":"数据库","data":[{"title":"我的mongodb操作手册","time":"2016-06-28 21:04:30","notebook":"数据库","_key":4,"id":"20160628","html":"<h1 id=\"-mongodb-\">我的mongodb操作手册</h1>\n<h2 id=\"-\">准备</h2>\n<ul>\n<li><p>下载</p>\n<pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>解压</p>\n<pre><code>tar -xvf mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>将mongodb中的bin 加入 $PATH</p>\n</li>\n</ul>\n<h2 id=\"-mongod-\">第一部分：mongod 的配置</h2>\n<blockquote>\n<p>mongod是mongodb主要的后台进程，它用来处理数据请求，管理数据存取，执行后台管理操作。在平常的使用中，一般通过一个config文件来管理数据库的行为。</p>\n</blockquote>\n<ul>\n<li>简单的配置\n<strong> myblog.conf</strong><pre><code>port = 27017\ndbpath = db\nlogpath = log/myblog.txt\nrest = true\n</code></pre></li>\n<li>启动 mongd<pre><code>sudo mongod --config myblog.conf\n</code></pre></li>\n</ul>\n<p>加入 --fork 进行后台运行</p>\n<p><em>是在那个配置文件的同一个目录中</em></p>\n<h2 id=\"-mongodb-shell-\">第二部分：mongodb shell 的命令</h2>\n<p>1、查询本地所有数据库名称        </p>\n<blockquote>\n<p>show dbs;</p>\n</blockquote>\n<p>2、切换至指定数据库环境（若无指定的数据库，则创建新的库）</p>\n<blockquote>\n<p>use mydb;</p>\n</blockquote>\n<p>3、查询当前库下的所有聚集集合collection（相当于table）</p>\n<blockquote>\n<p>show collections;</p>\n</blockquote>\n<p>4、创建聚集集合</p>\n<blockquote>\n<p>db.createCollection(&#39;mycollection&#39;);</p>\n</blockquote>\n<p> 5、查询聚集集合中数据条数</p>\n<blockquote>\n<p>db.mycollection.count();</p>\n</blockquote>\n<p>6、插入数据</p>\n<blockquote>\n<p>db.mycollection.insert({&#39;username&#39;:&#39;xyz_lmn&#39;,&#39;age&#39;:26,&#39;salary&#39;:120});</p>\n</blockquote>\n<p><em>往&#39;mycollection&#39;聚集集合中插上一条数库，name为&#39;xyz_lmn&#39;,age为&#39;26&#39;,salary为&#39;120&#39;</em></p>\n<p>7、查询age等于26的数据</p>\n<blockquote>\n<p>db.mycollection.find({&quot;age&quot;:<strong>26</strong>});</p>\n</blockquote>\n<p>8、查询salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>9、查询age小于30，salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({age:{$lt:<strong>30</strong>}},{salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>10、查询salary小于40或salary大于200的数据</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:200}}]});</p>\n</blockquote>\n<p>11、查询指定列的数据</p>\n<blockquote>\n<p>db.mycollection.find({},{age:<strong>1</strong>,salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>1表示显示此列的意思，也可以用true表示     12、查询username中包含&#39;e&#39;的数据</em></p>\n<blockquote>\n<p>db.mycollection.find({username:/e/});</p>\n</blockquote>\n<p>13、查询以a打头的数据</p>\n<blockquote>\n<p>db.mycollection.find({username:/^a/});</p>\n</blockquote>\n<p>14、查询age列数据，并去掉重复数据</p>\n<blockquote>\n<p>db.mycollection.distinct(&#39;age&#39;);</p>\n</blockquote>\n<p>15、查询前10条数据</p>\n<blockquote>\n<p>db.mycollection.find().limit(<strong>10</strong>);</p>\n</blockquote>\n<p>16、查询1条以后的所有数据</p>\n<blockquote>\n<p>db.mycollection.find().skip(<strong>1</strong>);</p>\n</blockquote>\n<p>17、查询第一条数据</p>\n<blockquote>\n<p>db.mycollection.findOne();</p>\n</blockquote>\n<p>18、查询结果集的记录数（查询salary小于40或大于100的记录数）</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:100}}]}).count();</p>\n</blockquote>\n<p>19、按salary升序排序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段升序排序</em>\n20、降序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:-<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段降序排序</em>\n21、根据username修改age</p>\n<blockquote>\n<p>db.employee.update({username:&#39;jim&#39;},{$set:{age:<strong>22</strong>}},false,true);</p>\n</blockquote>\n<pre><code>db.collection.update( criteria, objNew, upsert, multi )\ncriteria : update的查询条件，类似sql update查询内where后面的\nobjNew   : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\nupsert   : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\nmulti    : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n</code></pre><p>22、将指定username的age字段增加5</p>\n<blockquote>\n<p>db.mycollection.update({username:&#39;jim&#39;},{$inc:{age:<strong>5</strong>}},false,true);</p>\n</blockquote>\n<p><em>将username为‘jim’的age字段加5</em></p>\n<p>23、删除username为&#39;rose&#39;的数据</p>\n<blockquote>\n<p>db.mycollection.remove({uname:&#39;rose&#39;});</p>\n</blockquote>\n<p>24、集合collection重命名</p>\n<blockquote>\n<p>db.mycollection.renameCollection(&#39;c_temp&#39;);</p>\n</blockquote>\n<p><em>将mycollection集合重命名为&#39;c_temp&#39;</em>\n25、删除集合</p>\n<blockquote>\n<p>db.c_temp.drop();</p>\n</blockquote>\n<p><em>删除名为&#39;c_temp&#39;的集合</em>\n26、删除当前数据库</p>\n<blockquote>\n<p>db.dropDatabase();</p>\n</blockquote>\n<h2 id=\"-express-mongodb-\">第三部分：express 中操作mongodb数据库的一些要点</h2>\n<ul>\n<li>db.js</li>\n</ul>\n<pre><code>var settings = require(&#39;../settings.js&#39;);\nvar Db = require(&#39;mongodb&#39;).Db;\nvar Connection = require(&#39;mongodb&#39;).Connection;\nvar Server = require(&#39;mongodb&#39;).Server;\n\nmodule.exports = new Db(settings.db, new Server(settings.host, settings.port), {safe: true});\n</code></pre><ul>\n<li>user.js</li>\n</ul>\n<pre><code>var mongodb = require(&#39;./db&#39;);\nvar crypto = require(&#39;crypto&#39;);\n\nfunction User(user) {\n    this.username = user.username;\n    this.password = user.password;\n    this.email = user.email;\n}\nUser.prototype.get = function(username, callback) {\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.findOne({\n                username: username\n            }, function(err, data) {\n                if (err) {\n                    mongodb.close();\n                };\n                callback(null,data)\n            })\n        })\n    })\n}\n\nUser.prototype.save = function(callback) {\n    var user = {\n        username: this.username,\n        password: this.password,\n        email: this.email\n    };\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.insert(user, {\n                safe: true\n            }, function(err, data) {\n                mongodb.close();\n                if (err) {\n                    return callback(err);\n                };\n                callback(null, data)\n            });\n        });\n    });\n};\n\nmodule.exports = User;\n</code></pre><ul>\n<li>route.js</li>\n</ul>\n<pre><code>app.post(&#39;/signup&#39;,function(req, res){\n    var newUser = new User({\n      username: req.body.username,\n      password: req.body.password,\n      email: req.body.email\n    });\n    newUser.get(newUser.username, function(err, user){\n      if (user) {\n        res.send(user)\n      }else {\n        newUser.save(function(err, result){\n          if (err) {\n            res.send(err)\n          }else {\n            res.send(result)\n          }\n        })\n      }\n    })\n  })\n</code></pre>"}]}]