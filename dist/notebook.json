[{"nid":0,"notebook":"JavaScript","data":[{"title":"Promise 的实现过程（学习和简单翻译q）","time":"2017-03-12 10:09:21","notebook":"JavaScript","_key":17,"id":"20170305","html":"<h1 id=\"promise-\">Promise 的实现过程</h1>\n<p>This document is intended to explain how promises work and why this\nimplementation works its particular way by building a promise library incrementally and reviewing all of its major design decisions.  This is intended to leave the reader at liberty to experiment with variations of this implementation that suit their own requirements, without missing any important details.</p>\n<p>这篇文章打算解释 promise 是怎么工作的，然后通过一步一步地创建一个 promise library，展示它所有的设计思路，来解释它是如何实现它的特定的工作的。我们想让读者能够按照他们的需求去自由地去尝试这个实现方式的变化，然后又不会错过任何细节。</p>\n<hr>\n<p>Suppose that you&#39;re writing a function that can&#39;t return a value immediately.\nThe most obvious API is to forward the eventual value to a callback as an argument instead of returning the value.</p>\n<p>猜想你现在正在写一个不会立即返回一个value的function。\n最最容易想到的API 就是把最终的值作为一个参数用callback 带出来，而不是直接返回这个value。</p>\n<pre><code class=\"lang-javascript\">var oneOneSecondLater = function (callback) {\n    setTimeout(function () {\n        callback(1);\n    }, 1000);\n};\n</code></pre>\n<p>This is a very simple solution to a trival problem, but there is a lot of room for improvement.</p>\n<p>这是一个非常简单的方式来解决这个小问题，但是它存在很多可以改进的地方。</p>\n<p>A more general solution would provide analogous tools for both return values and thrown exceptions.  There are several obvious ways to extend the callback pattern to handle exceptions.  One is to provide both a callback and an errback.</p>\n<p>一个更加普遍的方式就是提供既能返回value又能抛出异常的工具。有很多可以想到的方式去扩展这个callback 来处理异常。其中一个就是提供一个callback 然后再提供一个 errback。</p>\n<pre><code class=\"lang-javascript\">var maybeOneOneSecondLater = function (callback, errback) {\n    setTimeout(function () {\n        if (Math.random() &lt; .5) {\n            callback(1);\n        } else {\n            errback(new Error(&quot;Can&#39;t provide one.&quot;));\n        }\n    }, 1000);\n};\n</code></pre>\n<p>There are other approaches, variations on providing the error as an argument to the callback, either by position or a distinguished sentinel value.</p>\n<p>要么通过位置，要么通过区分的值，作为一个callback参数提供error的方式肯定还有很多方法和变化形式。</p>\n<p>However, none of these approaches actually model thrown exceptions.  The purpose of exceptions and try/catch blocks is to postpone the explicit handling of exceptions until the program has returned to a point where it makes sense to attempt to recover.  There needs to be some mechanism for implicitly propagating exceptions if they are not handled.</p>\n<p>然而，这些方法都没有实际上模拟抛出异常。异常和 try/catch 块的目的就是去延迟异常的显式处理，直到程序返回一个有意义去尝试恢复的点。这就需要一些机制来隐式传递那些没有被处理的异常。</p>\n<h1 id=\"promises\">Promises</h1>\n<p>Consider a more general approach, where instead of returning values or throwing exceptions, functions return an object that represents the eventual result of the function, either sucessful or failed.  This object is a promise, both figuratively and by name, to eventually resolve.  We can call a function on the promise to observe either its fulfillment or rejection.  If the promise is rejected and the rejection is not explicitly observed, any derrived promises will be implicitly rejected for the same reason.</p>\n<p>考虑一个更加通用的方法，方法返回一个代表最终结果函数的object，而不是返回value或者抛出异常，而不是成功或者失败。这个object就是一个 promise，无论是比喻还是字面上理解，最终解决。我们可以在promise上面调用一个方法来观察它的实现或者拒绝。如果这个promise被拒绝了并且这个拒绝没有被明确地观察到，任何得到的promise将会由于同一个原因被隐含地拒绝。</p>\n<p>In this particular iteration of the design, we&#39;ll model a promise as an object with a &quot;then&quot; function that registers the callback.</p>\n<p>在这个特定的迭代设计中，我们将promise搭建成为一个能够注册回调的具有then方法的object。</p>\n<pre><code class=\"lang-javascript\">var maybeOneOneSecondLater = function () {\n    var callback;\n    setTimeout(function () {\n        callback(1);\n    }, 1000);\n    return {\n        then: function (_callback) {\n            callback = _callback;\n        }\n    };\n};\n\nmaybeOneOneSecondLater().then(callback);\n</code></pre>\n<p>This design has two weaknesses:</p>\n<ul>\n<li>The last caller of the then method determines the callback that is used.\nIt would be more useful if every registered callback were notified of\nthe resolution.</li>\n<li>If the callback is registered more than a second after the promise was\nconstructed, it won&#39;t be called.</li>\n</ul>\n<p>这个设计有两个缺点：</p>\n<ul>\n<li>then 方法的最后一次调用决定了要调用的callback。如果所有的callback能够被通知到解决的话，那就更加有效果了。</li>\n<li>如果callback 在promise建立后被注册了，那就它就不会被调用。</li>\n</ul>\n<p>A more general solution would accept any number of callbacks and permit them\nto be registered either before or after the timeout, or generally, the\nresolution event.  We accomplish this by making the promise a two-state object.</p>\n<p>一个更加通用的解决方案就是接受所有的callback然后允许它们在任何时候被注册，或者一般的解决事件。我们通过让promise变成两个状态的object来实现。</p>\n<p>A promise is initially unresolved and all callbacks are added to an array of\npending observers.  When the promise is resolved, all of the observers are\nnotified.  After the promise has been resolved, new callbacks are called\nimmediately.  We distinguish the state change by whether the array of pending\ncallbacks still exists, and we throw them away after resolution.</p>\n<p>promise刚开始还没resolve的时候，所有的callback被添加到一个等待中观察者的数组中。当这个promise被resolve的时候，所有的观察者被通知到。在promise被resolve之后，新的callback将会立即被调用。我们通过这个数组的pending callback是否还存在来区分状态的变化，然后我们在完成之后将它们丢弃。</p>\n<pre><code class=\"lang-javascript\">var maybeOneOneSecondLater = function () {\n    var pending = [], value;\n    setTimeout(function () {\n        value = 1;\n        for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n            var callback = pending[i];\n            callback(value);\n        }\n        pending = undefined;\n    }, 1000);\n    return {\n        then: function (callback) {\n            if (pending) {\n                pending.push(callback);\n            } else {\n                callback(value);\n            }\n        }\n    };\n};\n</code></pre>\n<p>This is already doing enough that it would be useful to break it into a\nutility function.  A deferred is an object with two parts: one for registering\nobservers and another for notifying observers of resolution.\n(see design/q0.js)</p>\n<p>这已经做的足够多了来变成一个有用的function。defer是一个有两部分的对象，一部分用来注册观察者，另一部分用来通知观察者去执行。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            value = _value;\n            for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                var callback = pending[i];\n                callback(value);\n            }\n            pending = undefined;\n        },\n        then: function (callback) {\n            if (pending) {\n                pending.push(callback);\n            } else {\n                callback(value);\n            }\n        }\n    }\n};\n\nvar oneOneSecondLater = function () {\n    var result = defer();\n    setTimeout(function () {\n        result.resolve(1);\n    }, 1000);\n    return result;\n};\n\noneOneSecondLater().then(callback);\n</code></pre>\n<p>The resolve function now has a flaw: it can be called multiple times, changing\nthe value of the promised result.  This fails to model the fact that a\nfunction only either returns one value or throws one error.  We can protect\nagainst accidental or malicious resets by only allowing only the first call to\nresolve to set the resolution.</p>\n<p>resolve 方法现在有个瑕疵，它可以被调用很多次，从而会改变已经得到的结果。\n这个就不能模拟一个函数只是返回一个值或者抛出一个异常。我们可以通过只允许第一次调用resolve 来设置结果来防止意外或者蓄意地重置。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = _value;\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    var callback = pending[i];\n                    callback(value);\n                }\n                pending = undefined;\n            } else {\n                throw new Error(&quot;A promise can only be resolved once.&quot;);\n            }\n        },\n        then: function (callback) {\n            if (pending) {\n                pending.push(callback);\n            } else {\n                callback(value);\n            }\n        }\n    }\n};\n</code></pre>\n<p>You can make an argument either for throwing an error or for ignoring all\nsubsequent resolutions.  One use-case is to give the resolver to a bunch of\nworkers and have a race to resolve the promise, where subsequent resolutions\nwould be ignored.  It&#39;s also possible that you do not want the workers to know\nwhich won.  Hereafter, all examples will ignore rather than fault on multiple\nresolution.</p>\n<p>你可以写个参数用来抛出异常或者忽略随后的所有的resolution。一个例子就是给resolver给一些workers 然后去竞争地resolve 这个promise，随后的resolution就要被忽略掉。也有可能你并不想让workers去知道谁执行了。下面，所有的例子在多个resolution的时候都是去忽略而不是去报错。</p>\n<p>At this point, defer can handle both multiple resolution and multiple\nobservation. (see design/q1.js)</p>\n<p>这一点，defer 可以处理多个resolution也可以处理多个observation。</p>\n<hr>\n<p>There are a few variations on this design which arise from two separate\ntensions.  The first tension is that it is both useful to separate or combine\nthe promise and resolver parts of the deferred.  It is also useful to have\nsome way of distinguishing promises from other values.</p>\n<p>这个设计有一些变化，产生于两个独立的张力。 第一个它能有效分离或结合promise和defer的resolve部分。 另一个用同一种方式将promise与其他value区分开来。</p>\n<p>-</p>\n<p>Separating the promise portion from the resolver allows us to code within the\nprinciple of least authority.  Giving someone a promise should give only the authority to observe the resolution and giving someone a resolver should only\ngive the authority to determine the resolution.  One should not implicitly give the other.  The test of time shows that any excess authority will inevitably be abused and will be very difficult to redact.</p>\n<p>将promise部分与resolver分开允许我们在内部进行编码最低权威原则。 给某人一个promise应该只给有权遵守决议并给予某人解决方案授权决定resolution。 一个不应该隐含给另一个。 时间的考验表明，任何多余的权威都会不可避免地被滥用，将非常难以编辑。</p>\n<p>The disadvantage of separation, however, is the additional burden on the\ngarbage collector to quickly dispose of used promise objects.</p>\n<p>然而，分离的缺点，就是给垃圾收集器额外的负担来快速处理用过的promise 对象。</p>\n<p>-</p>\n<p>Also, there are a variety of ways to distinguish a promise from other values.\nThe most obvious and strongest distinction is to use prototypical inheritance.\n(design/q2.js)</p>\n<p>此外，有各种方法来区分promise和其他值。最显而易见的区分就是使用原型继承。</p>\n<pre><code class=\"lang-javascript\">var Promise = function () {\n};\n\nvar isPromise = function (value) {\n    return value instanceof Promise;\n};\n\nvar defer = function () {\n    var pending = [], value;\n    var promise = new Promise();\n    promise.then = function (callback) {\n        if (pending) {\n            pending.push(callback);\n        } else {\n            callback(value);\n        }\n    };\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = _value;\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    var callback = pending[i];\n                    callback(value);\n                }\n                pending = undefined;\n            }\n        },\n        promise: promise\n    };\n};\n</code></pre>\n<p>Using prototypical inheritance has the disadvantage that only one instance of\na promise library can be used in a single program.  This can be difficult to\nenforce, leading to dependency enforcement woes.</p>\n<p>使用原型继承有个问题，就是在一个程序中只有promise的一个实例可以被使用。这个可能很难去执行，导致以来执行困难。</p>\n<p>Another approach is to use duck-typing, distinguishing promises from other\nvalues by the existence of a conventionally named method.  In our case,\nCommonJS/Promises/A establishes the use of &quot;then&quot; to distinguish its brand of\npromises from other values.  This has the disadvantage of failing to distinguish other objects that just happen to have a &quot;then&quot; method.  In practice, this is not a problem, and the minor variations in &quot;thenable&quot; implementations in the wild are manageable.</p>\n<p>另一种方法是使用鸭式，区分promises与其他值通过存在常规命名的方法。 在我们的例子中，CommonJS / Promises / A建立了使用“then”来区分其品牌承诺来自其他价值观。 这有缺点的不能区分刚刚发生的具有“then”方法的其他对象。 在实践，这不是一个问题，和“thenable”的微小变化在野外的实现是可管理的。</p>\n<pre><code class=\"lang-javascript\">var isPromise = function (value) {\n    return value &amp;&amp; typeof value.then === &quot;function&quot;;\n};\n\nvar defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = _value;\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    var callback = pending[i];\n                    callback(value);\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            then: function (callback) {\n                if (pending) {\n                    pending.push(callback);\n                } else {\n                    callback(value);\n                }\n            }\n        }\n    };\n};\n</code></pre>\n<p>The next big step is making it easy to compose promises, to make new promises\nusing values obtained from old promises.  Supposing that you have received promises for two numbers from a couple function calls, we would like to be able to create a promise for their sum.  Consider how this is achieved with callbacks.</p>\n<p>下一个大步骤是让它很容易撰写promise，使用从旧promise获得的值来做出新的promise。 假设你已经收到来自两个函数调用的两个数字的promise，我们希望能够为它们的总和创建一个promise。 考虑如何通过回调实现这一点。</p>\n<pre><code class=\"lang-javascript\">var twoOneSecondLater = function (callback) {\n    var a, b;\n    var consider = function () {\n        if (a === undefined || b === undefined)\n            return;\n        callback(a + b);\n    };\n    oneOneSecondLater(function (_a) {\n        a = _a;\n        consider();\n    });\n    oneOneSecondLater(function (_b) {\n        b = _b;\n        consider();\n    });\n};\n\ntwoOneSecondLater(function (c) {\n    // c === 2\n});\n</code></pre>\n<p>This approach is fragile for a number of reasons, particularly that there needs to be code to explicitly notice, in this case by a sentinel value, whether a callback has been called.  One must also take care to account for cases where callbacks are issued before the end of the event loop turn: the <code>consider</code> function must appear before it is used.</p>\n<p>这个方法是比较脆弱的，原因有很多，特别是需要代码明确地注意，在这个情况下，通过一个标记值，是否已经调用了callback。还必须注意在时间循环之前发出回调的情况：consider方法必须出现在它使用之前。</p>\n<p>In a few more steps, we will be able to accomplish this using promises in less code and handling error propagation implicitly.</p>\n<p>在更多的步骤中，我们将能够使用promise在更少的代码和隐式处理错误传播。</p>\n<pre><code class=\"lang-javascript\">var a = oneOneSecondLater();\nvar b = oneOneSecondLater();\nvar c = a.then(function (a) {\n    return b.then(function (b) {\n        return a + b;\n    });\n});\n</code></pre>\n<p>For this to work, several things have to fall into place:</p>\n<ul>\n<li>The &quot;then&quot; method must return a promise.</li>\n<li>The returned promise must be eventually resolved with the\nreturn value of the callback.</li>\n<li>The return value of the callback must be either a fulfilled\nvalue or a promise.</li>\n</ul>\n<p>为了这个工作，几个事情必须到位：</p>\n<ul>\n<li>then 方法必须返回一个promise。</li>\n<li>返回的promise必须最终用callback返回的值resolved。</li>\n<li>callback返回的值不能是fulfilled的值或者是一个promise。</li>\n</ul>\n<p>Converting values into promises that have already been fulfilled\nis straightforward.  This is a promise that immediately informs\nany observers that the value has already been fulfilled.</p>\n<p>将值转换为已经fulfill的promise是直接的。 这是一个立即通知所有observers的promise，这个值已经被fulfill了。</p>\n<pre><code class=\"lang-javascript\">var ref = function (value) {\n    return {\n        then: function (callback) {\n            callback(value);\n        }\n    };\n};\n</code></pre>\n<p>This method can be altered to coerce the argument into a promise\nregardless of whether it is a value or a promise already.</p>\n<p>这个方法可以改变以强制参数变成一个promise，不管它已经是一个值还是一个promise。</p>\n<pre><code class=\"lang-javascript\">var ref = function (value) {\n    if (value &amp;&amp; typeof value.then === &quot;function&quot;)\n        return value;\n    return {\n        then: function (callback) {\n            callback(value);\n        }\n    };\n};\n</code></pre>\n<p>Now, we need to start altering our &quot;then&quot; methods so that they return promises for the return value of their given callback. The &quot;ref&quot; case is simple.  We&#39;ll coerce the return value of the callback to a promise and return that immediately.</p>\n<p>现在，我们需要开始改变我们的“then”方法，使它们返回的 promise为它们给定callback的返回值。“ref”情况很简单。 我们将强制将callback的返回值变成promise并立即返回。</p>\n<pre><code class=\"lang-javascript\">var ref = function (value) {\n    if (value &amp;&amp; typeof value.then === &quot;function&quot;)\n        return value;\n    return {\n        then: function (callback) {\n            return ref(callback(value));\n        }\n    };\n};\n</code></pre>\n<p>This is more complicated for the deferred since the callback will be called in a future turn.  In this case, we recur on &quot;defer&quot; and wrap the callback.  The value returned by the callback will resolve the promise returned by &quot;then&quot;.</p>\n<p>这对于在未来从回调来的的延迟更复杂。 在这种情况下，我们再次“defer”并包装回调。 回调返回的值将会resolve “then”返回的promise。</p>\n<p>Furthermore, the &quot;resolve&quot; method needs to handle the case where the resolution is itself a promise to resolve later.  This is accomplished by changing the resolution value to a promise.  That is, it implements a &quot;then&quot; method, and can either be a promise returned by &quot;defer&quot; or a promise returned by &quot;ref&quot;.  If it&#39;s a &quot;ref&quot; promise, the behavior is identical to before: the callback is called immediately by &quot;then(callback)&quot;.  If it&#39;s a &quot;defer&quot; promise, the callback is passed forward to the next promise by calling &quot;then(callback)&quot;.  Thus, your callback is now observing a new promise for a more fully resolved value.  Callbacks can be forwarded many times, making &quot;progress&quot; toward an eventual resolution with each forwarding.</p>\n<p>此外，“resolve”方法需要处理resolution本身是以后解决的promise的情况。 这是通过将resolution值更改为promise来实现的。 也就是说，它实现了一个“then”方法，可以是由“defer”返回的promise或由“ref”返回的promise。 如果它是一个“ref”promise，其行为与之前相同：回调被“then（callback）”立即调用。 如果它是一个“defer”的promise，回调被传递到下一个promise通过调用“then（callback）”。 因此，您的回调现在正在观察一个新的承诺一个更完全resolved的值。 回调可以被转发多次，使得“progress”朝向每次转发的最终resolution。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = ref(_value); // values wrapped in a promise\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    var callback = pending[i];\n                    value.then(callback); // then called instead\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            then: function (_callback) {\n                var result = defer();\n                // callback is wrapped so that its return\n                // value is captured and used to resolve the promise\n                // that &quot;then&quot; returns\n                var callback = function (value) {\n                    result.resolve(_callback(value));\n                };\n                if (pending) {\n                    pending.push(callback);\n                } else {\n                    value.then(callback);\n                }\n                return result.promise;\n            }\n        }\n    };\n};\n</code></pre>\n<p>The implementation at this point uses &quot;thenable&quot; promises and separates the &quot;promise&quot; and &quot;resolve&quot; components of a &quot;deferred&quot;.\n(see design/q4.js)</p>\n<p>在这个时候，实现方法使用了 thenable promises 和一个defered 分离了promise 和 resolve。</p>\n<h1 id=\"error-propagation\">Error Propagation</h1>\n<p>To achieve error propagation, we need to reintroduce errbacks.  We use a new type of promise, analogous to a &quot;ref&quot; promise, that instead of informing a callback of the promise&#39;s fulfillment, it will inform the errback of its rejection and the reason why.</p>\n<p>为了实现错误传播，我们需要重新引入errbacks。 我们使用一种新的promise类型，类似于一个“ref”promise，它不是通知promise的回调的promise的实现，它会通知errback它的拒绝和原因。</p>\n<pre><code class=\"lang-javascript\">var reject = function (reason) {\n    return {\n        then: function (callback, errback) {\n            return ref(errback(reason));\n        }\n    };\n};\n</code></pre>\n<p>The simplest way to see this in action is to observe the resolution of\nan immediate rejection.</p>\n<p>看到这个在action的最简单的方法是观察的resolution立即拒绝。</p>\n<pre><code class=\"lang-javascript\">reject(&quot;Meh.&quot;).then(function (value) {\n    // we never get here\n}, function (reason) {\n    // reason === &quot;Meh.&quot;\n});\n</code></pre>\n<p>We can now revise our original errback use-case to use the promise\nAPI.</p>\n<p>我们现在可以修改我们的原始反馈用例来使用promise API。</p>\n<pre><code class=\"lang-javascript\">var maybeOneOneSecondLater = function (callback, errback) {\n    var result = defer();\n    setTimeout(function () {\n        if (Math.random() &lt; .5) {\n            result.resolve(1);\n        } else {\n            result.resolve(reject(&quot;Can&#39;t provide one.&quot;));\n        }\n    }, 1000);\n    return result.promise;\n};\n</code></pre>\n<p>To make this example work, the defer system needs new plumbing so that it can forward both the callback and errback components.  So, the array of pending callbacks will be replaced with an array of arguments for &quot;then&quot; calls.</p>\n<p>为了使此示例工作，延迟系统需要新的管道，以便它可以转发回调和errback组件。 因此，待处理回调的数组将被“then”调用的参数数组替换。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = ref(_value);\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    // apply the pending arguments to &quot;then&quot;\n                    value.then.apply(value, pending[i]);\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            then: function (_callback, _errback) {\n                var result = defer();\n                var callback = function (value) {\n                    result.resolve(_callback(value));\n                };\n                var errback = function (reason) {\n                    result.resolve(_errback(reason));\n                };\n                if (pending) {\n                    pending.push([callback, errback]);\n                } else {\n                    value.then(callback, errback);\n                }\n                return result.promise;\n            }\n        }\n    };\n};\n</code></pre>\n<p>There is, however, a subtle problem with this version of &quot;defer&quot;.  It mandates that an errback must be provided on all &quot;then&quot; calls, or an exception will be thrown when trying to call a non-existant function.  The simplest solution to this problem is to provide a default errback that forwards the rejection.  It is also reasonable for the callback to be omitted if you&#39;re only interested in observing rejections, so we provide a default callback that forwards the fulfilled value.</p>\n<p>但是，这个版本的“defer”有一个微妙的问题。 它要求必须在所有“then”调用上提供errback，或者在尝试调用不存在的函数时抛出异常。 此问题的最简单的解决方案是提供转发拒绝的默认errback。 如果你只关注观察拒绝，那么回调被省略也是合理的，所以我们提供一个默认的callback来转发fulfill的值。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = ref(_value);\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    value.then.apply(value, pending[i]);\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            then: function (_callback, _errback) {\n                var result = defer();\n                // provide default callbacks and errbacks\n                _callback = _callback || function (value) {\n                    // by default, forward fulfillment\n                    return value;\n                };\n                _errback = _errback || function (reason) {\n                    // by default, forward rejection\n                    return reject(reason);\n                };\n                var callback = function (value) {\n                    result.resolve(_callback(value));\n                };\n                var errback = function (reason) {\n                    result.resolve(_errback(reason));\n                };\n                if (pending) {\n                    pending.push([callback, errback]);\n                } else {\n                    value.then(callback, errback);\n                }\n                return result.promise;\n            }\n        }\n    };\n};\n</code></pre>\n<p>At this point, we&#39;ve achieved composition and implicit error propagation.  We can now very easily create promises from other promises either in serial or in parallel (see design/q6.js).  This example creates a promise for the eventual sum of promised values.</p>\n<p>在这一点上，我们已经实现了组合和隐式错误传播。 我们现在可以很容易地从串行或并行的其他promise创建promise（见design / q6.js）。 此示例为promise的值的最终和创建一个promise。</p>\n<pre><code class=\"lang-javascript\">promises.reduce(function (accumulating, promise) {\n    return accumulating.then(function (accumulated) {\n        return promise.then(function (value) {\n            return accumulated + value;\n        });\n    });\n}, ref(0)) // start with a promise for zero, so we can call then on it\n           // just like any of the combined promises\n.then(function (sum) {\n    // the sum is here\n});\n</code></pre>\n<h1 id=\"safety-and-invariants\">Safety and Invariants</h1>\n<p>Another incremental improvement is to make sure that callbacks and errbacks are called in future turns of the event loop, in the same order that they were registered.  This greatly reduces the number of control-flow hazards inherent to asynchronous programming.  Consider a brief and contrived example:</p>\n<p>另一个增量改进是确保在事件循环的未来轮次中调用回调和errback，顺序与它们注册的顺序相同。 这大大减少了异步编程固有的控制流危险的数量。 考虑一个简单的和设计的例子：</p>\n<pre><code class=\"lang-javascript\">var blah = function () {\n    var result = foob().then(function () {\n        return barf();\n    });\n    var barf = function () {\n        return 10;\n    };\n    return result;\n};\n</code></pre>\n<p>This function will either throw an exception or return a promise that will quickly be fulfilled with the value of 10.  It depends on whether foob() resolves in the same turn of the event loop (issuing its callback on the same stack immediately) or in a future turn.  If the callback is delayed to a future turn, it will allways succeed.\n(see design/q7.js)</p>\n<p>这个函数将抛出一个异常或者返回一个promise，它很快就会被赋值为10.它取决于foob（）是否在同一个事件循环中解决（立即在同一堆栈上发出它的回调），或者在未来的回合。 如果回调被延迟到未来的回合，它将会成功。\n（见设计/ q7.js）</p>\n<pre><code class=\"lang-javascript\">var enqueue = function (callback) {\n    //process.nextTick(callback); // NodeJS\n    setTimeout(callback, 1); // Naïve browser solution\n};\n\nvar defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = ref(_value);\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    // XXX\n                    enqueue(function () {\n                        value.then.apply(value, pending[i]);\n                    });\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            then: function (_callback, _errback) {\n                var result = defer();\n                _callback = _callback || function (value) {\n                    return value;\n                };\n                _errback = _errback || function (reason) {\n                    return reject(reason);\n                };\n                var callback = function (value) {\n                    result.resolve(_callback(value));\n                };\n                var errback = function (reason) {\n                    result.resolve(_errback(reason));\n                };\n                if (pending) {\n                    pending.push([callback, errback]);\n                } else {\n                    // XXX\n                    enqueue(function () {\n                        value.then(callback, errback);\n                    });\n                }\n                return result.promise;\n            }\n        }\n    };\n};\n\nvar ref = function (value) {\n    if (value &amp;&amp; value.then)\n        return value;\n    return {\n        then: function (callback) {\n            var result = defer();\n            // XXX\n            enqueue(function () {\n                result.resolve(callback(value));\n            });\n            return result.promise;\n        }\n    };\n};\n\nvar reject = function (reason) {\n    return {\n        then: function (callback, errback) {\n            var result = defer();\n            // XXX\n            enqueue(function () {\n                result.resolve(errback(reason));\n            });\n            return result.promise;\n        }\n    };\n};\n</code></pre>\n<p>There remains one safty issue, though.  Given that any object that implements &quot;then&quot; is treated as a promise, anyone who calls &quot;then&quot; directly is at risk of surprise.</p>\n<p>但仍有一个安全问题。 假设实现“then”的对象被视为promise，那么任何直接调用“then”的人都会有意外的风险。</p>\n<ul>\n<li>The callback or errback might get called in the same turn</li>\n<li>The callback and errback might both be called</li>\n<li>The callback or errback might be called more than once</li>\n</ul>\n<ul>\n<li>callback 和 errback 可能在同一个回合被调用。</li>\n<li>callback 和 errback 可能两个都被调用。</li>\n<li>callback 和 errback 可能被调用不止一次。</li>\n</ul>\n<p>A &quot;when&quot; method wraps a promise and prevents these surprises.</p>\n<p>when 方法包装了promise 然后可以阻止这些意外。</p>\n<p>We can also take the opportunity to wrap the callback and errback\nso that any exceptions thrown get transformed into rejections.</p>\n<p>我们还是可以利用机会去包装callback 和 errback，以至于任何抛出的异常都会被转换到rejection里面去。</p>\n<pre><code class=\"lang-javascript\">var when = function (value, _callback, _errback) {\n    var result = defer();\n    var done;\n\n    _callback = _callback || function (value) {\n        return value;\n    };\n    _errback = _errback || function (reason) {\n        return reject(reason);\n    };\n\n    var callback = function (value) {\n        try {\n            return _callback(value);\n        } catch (reason) {\n            return reject(reason);\n        }\n    };\n    var errback = function (reason) {\n        try {\n            return _errback(reason);\n        } catch (reason) {\n            return reject(reason);\n        }\n    };\n\n    enqueue(function () {\n        ref(value).then(function (value) {\n            if (done)\n                return;\n            done = true;\n            result.resolve(ref(value).then(callback, errback));\n        }, function (reason) {\n            if (done)\n                return;\n            done = true;\n            result.resolve(errback(reason));\n        });\n    });\n\n    return result.promise;\n};\n</code></pre>\n<p>At this point, we have the means to protect ourselves against several\nsurprises including unnecessary non-deterministic control-flow in the course of an event and broken callback and errback control-flow invariants.\n(see design/q7.js)</p>\n<p>在这一点上，我们有办法保护自己免受几个意外，包括在事件过程中不必要的非确定性控制流和破坏的回调和错误控制流不变量。</p>\n<h1 id=\"message-passing\">Message Passing</h1>\n<p>If we take a step back, promises have become objects that receive &quot;then&quot; messages.  Deferred promises forward those messages to their resolution promise.  Fulfilled promises respond to then messages by calling the callback with the fulfilled value.  Rejected promises respond to then messages by calling the errback with the rejection reason.</p>\n<p>如果我们退后一步，promise已经成为接收“then”消息的对象。 defer的promise将这些信息转发给他们的resolution promise。 fulfill的promise通过调用具有满足值的回调来响应然后的消息。 reject的promise通过调用具有拒绝原因的errback响应然后消息。</p>\n<p>We can generalize promises to be objects that receive arbitrary messages, including &quot;then/when&quot; messages.  This is useful if there is a lot of latency preventing the immediate observation of a promise&#39;s resolution, as in a promise that is in another process or worker or another computer on a network.</p>\n<p>我们可以将promise概括为接收任意消息的对象，包括“then / when”消息。 如果有大量延迟阻止立即观察承诺的解决方案，如在另一个进程或工作线程或网络上的另一台计算机中的promise，这是非常有用的。</p>\n<p>If we have to wait for a message to make a full round-trip across a network to get a value, the round-trips can add up a lot and much time will be wasted. This ammounts to &quot;chatty&quot; network protocol problems, which are the downfall of SOAP and RPC in general.</p>\n<p>如果我们必须等待一个消息，通过网络做一个完整的往返，以获得一个价值，往返行程可以累加很多，很多时间会浪费。 这就是“chatty”网络协议问题，这是SOAP和RPC的失败。</p>\n<p>However, if we can send a message to a distant promise before it resolves, the remote promise can send responses in rapid succession.  Consider the case where an object is housed on a remote server and cannot itself be sent across the network; it has some internal state and capabilities that cannot be serialized, like access to a database.  Suppose we obtain a promise for this object and can now send messages.  These messages would likely mostly\ncomprise method calls like &quot;query&quot;, which would in turn send promises back.</p>\n<p>然而，如果我们可以在它解析之前向远程promise发送消息，则远程promise可以快速连续地发送响应。 考虑其中对象容纳在远程服务器上并且本身不能通过网络发送的情况; 它有一些内部状态和功能，无法序列化，如访问数据库。 假设我们获得了这个对象的promise，现在可以发送消息。 这些消息可能主要包括诸如“查询”的方法调用，其将反过来发送promise。</p>\n<hr>\n<p>We must found a new family of promises based on a new method that sends arbitrary messages to a promise.  &quot;promiseSend&quot; is defined by\nCommonJS/Promises/D.  Sending a &quot;when&quot; message is equivalent to calling the &quot;then&quot; method.</p>\n<p>我们必须找到一个新的承诺的家庭基于一个新的方法，发送任意消息的承诺。 “promiseSend”由定义 CommonJS / Promises / D。 发送“when”消息等同于调用“then”方法。</p>\n<pre><code class=\"lang-javascript\">promise.then(callback, errback);\npromise.promiseSend(&quot;when&quot;, callback, errback);\n</code></pre>\n<p>We must revisit all of our methods, building them on &quot;promiseSend&quot; instead of &quot;then&quot;.  However, we do not abandon &quot;then&quot; entirely; we still produce and consume &quot;thenable&quot; promises, routing their message through &quot;promiseSend&quot; internally.</p>\n<p>我们必须重新访问所有的方法，在“promiseSend”而不是“then”上构建它们。 然而，我们不会完全放弃“then” 我们仍然产生和消费“thenable”promise，通过“promiseSend”在内部路由他们的消息。</p>\n<pre><code class=\"lang-javascript\">function Promise() {}\nPromise.prototype.then = function (callback, errback) {\n    return when(this, callback, errback);\n};\n</code></pre>\n<p>If a promise does not recognize a message type (an &quot;operator&quot; like &quot;when&quot;),it must return a promise that will be eventually rejected.</p>\n<p>如果promise不能识别消息类型（一个“运算符”，例如“when”），它必须返回一个最终被拒绝的promise。</p>\n<p>Being able to receive arbitrary messages means that we can also implement new types of promise that serves as a proxy for a remote promise, simply forwarding all messages to the remote promise and forwarding all of its responses back to promises in the local worker.</p>\n<p>能够接收任意消息意味着我们还可以实现用作远程promise的代理的新类型的promise，简单地将所有消息转发到远程promise并将其所有响应转发回本地工作者中的promise。</p>\n<p>Between the use-case for proxies and rejecting unrecognized messages, it is useful to create a promise abstraction that routes recognized messages to a handler object, and unrecognized messages to a fallback method.</p>\n<p>在代理的用例和拒绝不可识别的消息之间，创建一个promise抽象，将已识别的消息路由到处理程序对象，并将无法识别的消息路由到回退方法是有用的。</p>\n<pre><code class=\"lang-javascript\">var makePromise = function (handler, fallback) {\n    var promise = new Promise();\n    handler = handler || {};\n    fallback = fallback || function (op) {\n        return reject(&quot;Can&#39;t &quot; + op);\n    };\n    promise.promiseSend = function (op, callback) {\n        var args = Array.prototype.slice.call(arguments, 2);\n        var result;\n        callback = callback || function (value) {return value};\n        if (handler[op]) {\n            result = handler[op].apply(handler, args);\n        } else {\n            result = fallback.apply(handler, [op].concat(args));\n        }\n        return callback(result);\n    };\n    return promise;\n};\n</code></pre>\n<p>Each of the handler methods and the fallback method are all expected to return a value which will be forwarded to the callback.  The handlers do not receive their own name, but the fallback does receive the operator name so it can route it.  Otherwise, arguments are passed through.</p>\n<p>每个处理程序方法和回退方法都希望返回一个值，该值将被转发到回调。 处理程序不接收自己的名称，但是后备接收操作员名称，以便它可以路由它。 否则，传递参数。</p>\n<p>For the &quot;ref&quot; method, we still only coerce values that are not already\npromises.  We also coerce &quot;thenables&quot; into &quot;promiseSend&quot; promises.\nWe provide methods for basic interaction with a fulfilled value, including property manipulation and method calls.</p>\n<p>对于“ref”方法，我们仍然只强制值已经不是promise。 我们也强迫“thenables”成“promiseSend”承诺。我们提供了与满足值的基本交互的方法，包括属性操作和方法调用。</p>\n<pre><code class=\"lang-javascript\">var ref = function (object) {\n    if (object &amp;&amp; typeof object.promiseSend !== &quot;undefined&quot;) {\n        return object;\n    }\n    if (object &amp;&amp; typeof object.then !== &quot;undefined&quot;) {\n        return makePromise({\n            when: function () {\n                var result = defer();\n                object.then(result.resolve, result.reject);\n                return result;\n            }\n        }, function fallback(op) {\n            return Q.when(object, function (object) {\n                return Q.ref(object).promiseSend.apply(object, arguments);\n            });\n        });\n    }\n    return makePromise({\n        when: function () {\n            return object;\n        },\n        get: function (name) {\n            return object[name];\n        },\n        put: function (name, value) {\n            object[name] = value;\n        },\n        del: function (name) {\n            delete object[name];\n        }\n    });\n};\n</code></pre>\n<p>Rejected promises simply forward their rejection to any message.</p>\n<p>rejected promise 只是转发他们rejection任何消息。</p>\n<pre><code class=\"lang-javascript\">var reject = function (reason) {\n    var forward = function (reason) {\n        return reject(reason);\n    };\n    return makePromise({\n        when: function (errback) {\n            errback = errback || forward;\n            return errback(reason);\n        }\n    }, forward);\n};\n</code></pre>\n<p>Defer sustains very little damage.  Instead of having an array of arguments to forward to &quot;then&quot;, we have an array of arguments to forward to &quot;promiseSend&quot;. &quot;makePromise&quot; and &quot;when&quot; absorb the responsibility for handling the callback and errback argument defaults and wrappers.</p>\n<p>defer受到的伤害很小。 而不是有一个参数数组转发到“then”，我们有一个参数数组转发到“promiseSend”。 “makePromise”和“when”吸收处理回调和errback参数默认值和包装器的责任。</p>\n<pre><code class=\"lang-javascript\">var defer = function () {\n    var pending = [], value;\n    return {\n        resolve: function (_value) {\n            if (pending) {\n                value = ref(_value);\n                for (var i = 0, ii = pending.length; i &lt; ii; i++) {\n                    enqueue(function () {\n                        value.promiseSend.apply(value, pending[i]);\n                    });\n                }\n                pending = undefined;\n            }\n        },\n        promise: {\n            promiseSend: function () {\n                var args = Array.prototype.slice.call(arguments);\n                var result = defer();\n                if (pending) {\n                    pending.push(args);\n                } else {\n                    enqueue(function () {\n                        value.promiseSend.apply(value, args);\n                    });\n                }\n            }\n        }\n    };\n};\n</code></pre>\n<p>The last step is to make it syntactically convenient to send messages to promises.  We create &quot;get&quot;, &quot;put&quot;, &quot;post&quot; and &quot;del&quot; functions that send the corresponding messages and return promises for the results.  They all look very similar.</p>\n<p>最后一步是使语法方便地向promise发送消息。 我们创建“get”，“put”，“post”和“del”函数，发送相应的消息并返回结果的promise。 他们都看起来很相似。</p>\n<pre><code class=\"lang-javascript\">var get = function (object, name) {\n    var result = defer();\n    ref(object).promiseSend(&quot;get&quot;, result.resolve, name);\n    return result.promise;\n};\n\nget({&quot;a&quot;: 10}, &quot;a&quot;).then(function (ten) {\n    // ten === ten\n});\n</code></pre>\n<p>The last improvment to get promises up to the state-of-the-art is to rename all of the callbacks to &quot;win&quot; and all of the errbacks to &quot;fail&quot;.  I&#39;ve left this as an exercise.</p>\n<p>获得最新技术的最后一个改进是将所有回调重命名为“win”，并将所有redback重命名为“fail”。 我把这作为一个练习。</p>\n<h1 id=\"future\">Future</h1>\n<p>Andrew Sutherland did a great exercise in creating a variation of the Q library that supported annotations so that waterfalls of promise creation, resolution, and dependencies could be graphically depicited.  Optional annotations and a debug variation of the Q library would be a logical next-step.</p>\n<p>There remains some question about how to ideally cancel a promise.  At the moment, a secondary channel would have to be used to send the abort message.\nThis requires further research.</p>\n<p>CommonJS/Promises/A also supports progress notification callbacks.  A variation of this library that supports implicit composition and propagation of progress information would be very awesome.</p>\n<p>It is a common pattern that remote objects have a fixed set of methods, all of which return promises.  For those cases, it is a common pattern to create a local object that proxies for the remote object by forwarding all of its method calls to the remote object using &quot;post&quot;.  The construction of such proxies could be automated.  Lazy-Arrays are certainly one use-case.</p>\n<p>简单翻译自 <a href=\"https://github.com/kriskowal/q/tree/v1/design\">kriskowal/q</a></p>\n"},{"title":"promise 实现 (promise implementing 翻译)","time":"2017-03-03 16:52:12","notebook":"JavaScript","_key":16,"id":"20170303","html":"<h1 id=\"promise-promise-implementing-\">promise 实现 (promise implementing 翻译)</h1>\n<h2 id=\"introduction\">Introduction</h2>\n<p>This article was originally written as an answer on <a href=\"http://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244#23785244\">Stack Overflow</a>. The hope is that by seeing how you would go about implementing <code>Promise</code>\n in JavaScript, you may gain a better understanding of how promises behave.</p>\n<h2 id=\"-\">介绍</h2>\n<p>这篇文章起初是在Stack Overflow网站里的一个回答。希望大家看完在 JavaScript 去实现 Promise 这个过程之后，可以更好地理解 promise。</p>\n<h2 id=\"state-machine\">State Machine</h2>\n<p>Since a promise is just a state machine, we should start by considering the state information we will need later.</p>\n<p>既然 promise 仅仅是一个 state machine， 我们应该先考虑待会儿要用到的 state 信息。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers attached by calling .then or .done\n  // attached 附上的\n  var handlers = [];\n}\n</code></pre>\n<h2 id=\"transitions\">Transitions</h2>\n<p>Next, lets consider the two key transitions that can occur, fulfilling and rejecting:</p>\n<p>接下来，我们就来考虑这两个关键的转换， funfilling 和 rejecting：</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n}\n</code></pre>\n<p>That gives us the basic low level transitions, but lets consider an extra, higher-level transition called <code>resolve</code>.</p>\n<p>它给了我们最基本的转换，但让我们考虑一个其他的，更高级的方法：resolve。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n\n  function resolve(result) {\n    try {\n      var then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject)\n        return\n      }\n      fulfill(result);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n</code></pre>\n<p>Note how <code>resolve</code> accepts either a promise or a plain value and if it&#39;s a promise, waits for it to complete. A promise must never be fulfilled with another promise, so it is this <code>resolve</code> function that we will expose, rather than the internal <code>fulfill</code>. We&#39;ve used a couple of helper methods, so lets define those:</p>\n<p>展示了如何 resolve 接收一个 promise 或者一个值，如果是 promise 的话，就等待它执行完在接收。 promise 必须没有被另一个promise fulfilled。所以我们才暴露这个 resolve 方法，而不是内部的fulfill。我们已经用了一些helper方法， 下面就是这些方法。</p>\n<pre><code>/**\n * Check if a value is a Promise and, if it is,\n * return the `then` method of that promise.\n * 检查是否是 Promise 如果是的话，就返回那个 promise 的 then 方法。\n *\n * @param {Promise|Any} value\n * @return {Function|Null}\n */\nfunction getThen(value) {\n  var t = typeof value;\n  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) {\n    var then = value.then;\n    if (typeof then === &#39;function&#39;) {\n      return then;\n    }\n  }\n  return null;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n *\n * @param {Function} fn A resolver function that may not be trusted\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n</code></pre><h2 id=\"constructing\">Constructing</h2>\n<p>We now have the completed internal state machine, but we have yet to expose either a method of resolving the promise or of observing it. Lets start by adding a way of resolving the promise.</p>\n<p>我们已经完成了state machine，但是我们还没暴露一个resolving方法。让我们开始添加这个方法吧。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise(fn) {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n\n  function resolve(result) {\n    try {\n      var then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject)\n        return\n      }\n      fulfill(result);\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  doResolve(fn, resolve, reject);\n}\n</code></pre>\n<p>As you can see, we re-use <code>doResolve</code> because we have another untrusted resolver. The fn is allowed to call both <code>resolve</code> and <code>reject</code> multiple times, and even throw exceptions. It is up to us to ensure that the promise is only resolved or rejected once, and then never transitions into a different state ever again.</p>\n<p>就如你们看到的，我们复用了 doResolve 这个方法。因为我们有另外一个不确定的 resolver 。fn 方法允许调用 resolve 和 reject 方法很多次，甚至会抛出异常。 这取决于我们去保证 promise 只是被 resolve 或者 reject 一次，然后再也不会改变它的 state。</p>\n<h2 id=\"observing-via-done-\">Observing (via .done)</h2>\n<p>We now have a completed state machine, but we still have no way to observe any changes to it. Our ultimate goal is to implement <code>.then</code>, but the semantics of <code>.done</code> are much simpler so lets implement that first.</p>\n<p>Our goal here is to implement <code>promise.done(onFulfilled, onRejected)</code> such that:</p>\n<ul>\n<li>only one of <code>onFulfilled</code> or <code>onRejected</code> is called</li>\n<li>it is only called once</li>\n<li>it is never called until the next tick (i.e. after the <code>.done</code> method has returned)</li>\n<li>it is called regardless of whether the promise is resolved before or after we call <code>.done</code></li>\n</ul>\n<p>我们现在已经完成了 state machine, 但是我们还是没有方法去观察它的任何改变。我们最终的目标就是去实现 .then ，我们先实现它的话，那么 .done 将会更加容易实现。</p>\n<p>我们在这里的目标就是去实现 promise.done(onFulfilled, onRejected)\n像下面这样：</p>\n<ul>\n<li>onFulfilled 或者 onRejected 只能其中一个被调用</li>\n<li>只能被调用一次</li>\n<li>直到下一个标记才会被调用（比日说在 .done 方法被 return 了）</li>\n<li>调用的时候，不管这个 promise 是否在我们调用 .done 之前或者之后被 resolved</li>\n</ul>\n<pre><code class=\"lang-JavaScript\">this.then = function (onFulfilled, onRejected) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    return self.done(function (result) {\n      if (typeof onFulfilled === &#39;function&#39;) {\n        try {\n          return resolve(onFulfilled(result));\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return resolve(result);\n      }\n    }, function (error) {\n      if (typeof onRejected === &#39;function&#39;) {\n        try {\n          return resolve(onRejected(error));\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return reject(error);\n      }\n    });\n  });\n}\n</code></pre>\n<h2 id=\"further-reading\">Further Reading</h2>\n<ul>\n<li><a href=\"https://github.com/then/promise/blob/master/src/core.js\">then/promise</a> implements Promise in a very similar way.</li>\n<li><a href=\"https://github.com/kriskowal/q/blob/v1/design/README.js\">kriskowal/q</a> is a very different implementation of promises and comes with a very nice walkthrough of the design principals behind it.</li>\n<li><a href=\"https://github.com/petkaantonov/bluebird\">petkaantonov/bluebird</a> is a promise implementation that was designed exclusively for performance (along with its own esoteric helper methods). The <a href=\"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\">Optimization Killers</a> Wiki page is extremely useful for picking up tips.</li>\n<li><a href=\"http://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244#23785244\">Stack Overflow</a> is the original source of this article.</li>\n</ul>\n"},{"title":"跨域的学习","time":"2017-03-02 20:24:29","notebook":"JavaScript","_key":15,"id":"20170302","html":"<h1 id=\"-\">跨域的学习</h1>\n<h2 id=\"-\">什么是跨域？</h2>\n<blockquote>\n<p>只要协议、域名、端口有任何一个不同，都被当做是不同的域。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>url</th>\n<th>说明</th>\n<th>是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名下</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/lab/a.js\">http://www.a.com/lab/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/script/b.js\">http://www.a.com/script/b.js</a></td>\n<td>同一域名下不同文件夹</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com:8000/a.js\">http://www.a.com:8000/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名，不同端口</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.a.com/b.js\">https://www.a.com/b.js</a></td>\n<td>同一域名，不同协议</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://70.32.92.74/b.js\">http://70.32.92.74/b.js</a></td>\n<td>域名和域名对应ip</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://script.a.com/b.js\">http://script.a.com/b.js</a></td>\n<td>主域相同，子域不同</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://a.com/b.js\">http://a.com/b.js</a></td>\n<td>同一域名，不同二级域名（同上）</td>\n<td>不允许（cookie这种情况下也不允许访问）</td>\n</tr>\n<tr>\n<td><a href=\"http://www.cnblogs.com/a.js\">http://www.cnblogs.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>不同域名</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>对于端口和协议的不同，只能通过后台来解决。</p>\n</blockquote>\n<h2 id=\"cors-cross-origin-resource-sharing-\">CORS（Cross-origin resource sharing）跨域资源共享</h2>\n<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>\n<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>\n<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>\n<p>CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    var xhr = new XMLHttpRequest();\n    xhr.open(&quot;￼GET&quot;, &quot;/trigkit4&quot;,true);\n    xhr.send();\n&lt;/script&gt;\n</code></pre>\n<p>以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    var xhr = new XMLHttpRequest();\n    xhr.open(&quot;￼GET&quot;, &quot;http://segmentfault.com/u/trigkit4/&quot;,true);\n    xhr.send();\n&lt;/script&gt;\n</code></pre>\n<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>\n<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<h2 id=\"jsonp-json-with-padding-\">JSONP (JSON with Padding)</h2>\n<p>JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：</p>\n<pre><code class=\"lang-javascript\">callback({&quot;name&quot;,&quot;trigkit4&quot;});\n</code></pre>\n<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n&lt;/script&gt;\n&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<pre><code class=\"lang-PHP\">&lt;?php\n$callback = $_GET[&#39;callback&#39;];//得到回调函数名\n$data = array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);//要返回的数据\necho $callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;//输出\n?&gt;\n</code></pre>\n<p>最终，输出结果为：dosomething([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);</p>\n<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    $.getJSON(&#39;http://example.com/data.php?callback=?,function(jsondata)&#39;){\n        //处理获得的json数据\n    });\n&lt;/script&gt;\n</code></pre>\n<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>\n<blockquote>\n<p>JSONP的优缺点</p>\n<p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>\n<p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>\n</blockquote>\n<ul>\n<li>CORS和JSONP对比</li>\n</ul>\n<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>\n<blockquote>\n<ol>\n<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>\n</li>\n<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>\n</li>\n<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"-document-domain-\">通过修改document.domain来跨子域</h2>\n<p>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。</p>\n<p>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href=\"http://example.com/b.html\">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function test(){\n        var iframe = document.getElementById(&#39;￼ifame&#39;);\n        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n&lt;/script&gt;\n&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;\n</code></pre>\n<p>这个时候，document.domain就可以派上用场了，我们只要把<a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> 和 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> 这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>\n<ul>\n<li>在页面 <a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> 中设置document.domain:</li>\n</ul>\n<pre><code>&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    document.domain = &#39;example.com&#39;;//设置成主域\n    function test(){\n        alert(document.getElementById(&#39;￼iframe&#39;).contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n&lt;/script&gt;\n</code></pre><ul>\n<li>在页面 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> 中也设置document.domain:</li>\n</ul>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    document.domain = &#39;example.com&#39;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n&lt;/script&gt;\n</code></pre>\n<p>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h2 id=\"-window-name-\">使用window.name来进行跨域</h2>\n<p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h2 id=\"-html5-window-postmessage-\">使用HTML5的window.postMessage方法跨域</h2>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>\n<h2 id=\"-\">参考资料</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000718840\">https://segmentfault.com/a/1190000000718840</a></li>\n<li><a href=\"http://www.cnblogs.com/2050/p/3191744.html\">http://www.cnblogs.com/2050/p/3191744.html</a></li>\n<li><a href=\"https://qiutc.me/post/cross-domain-collections.html\">https://qiutc.me/post/cross-domain-collections.html</a></li>\n</ul>\n"},{"title":"fetch 学习笔记","time":"2017-03-01 14:44:12","notebook":"JavaScript","_key":14,"id":"20170301","html":"<h1 id=\"fetch-\">fetch 学习笔记</h1>\n<blockquote>\n<h3 id=\"ajax-asynchronous-javascript-and-xml-\">AJAX ( Asynchronous JavaScript and XML )</h3>\n<p>AJAX 指的是一套综合了多项技术的浏览器端网页开发技术。AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。</p>\n</blockquote>\n<h3 id=\"xmlhttprequest\">XmlHttpRequest</h3>\n<p>在大家印象中AJAX技术主要指的是XmlHttpRequest对象，它在不同浏览器中有不同的创建方法，以下是跨浏览器的通用方法：</p>\n<pre><code>// Provide the XMLHttpRequest class for IE 5.x-6.x:\n// Other browsers (including IE 7.x-8.x) ignore this\n//   when XMLHttpRequest is predefined\nvar xmlHttp;\nif (typeof XMLHttpRequest != &quot;undefined&quot;) {\n    xmlHttp = new XMLHttpRequest();\n} else if (window.ActiveXObject) {\n    var aVersions = [&quot;Msxml2.XMLHttp.5.0&quot;, &quot;Msxml2.XMLHttp.4.0&quot;, &quot;Msxml2.XMLHttp.3.0&quot;, &quot;Msxml2.XMLHttp&quot;, &quot;Microsoft.XMLHttp&quot;];\n    for (var i = 0; i &lt; aVersions.length; i++) {\n        try {\n            xmlHttp = new ActiveXObject(aVersions[i]);\n            break;\n        } catch (e) {}\n    }\n}\n</code></pre><p>它的一个基本使用方法：</p>\n<pre><code>function reqListener() {\n  const data = JSON.parse(this.responseText);\n  console.log(data)\n}\n\nfunction reqError(err) {\n  console.log(&#39;Fetch Error :-S&#39;, err)\n}\n\nconst oReq = new XMLHttpRequest();\noReq.onload = reqListener\noReq.onerror = reqError\noReq.open(&#39;get&#39;, &#39;./sample.json&#39;, true)\noReq.send()\n</code></pre><h3 id=\"jquery\">jQuery</h3>\n<pre><code>$.ajax({\n    url: &#39;./sample.json&#39;,\n    data: {\n        id: &#39;a001&#39;\n    },\n    type: &#39;GET&#39;,\n    dataType : &#39;json&#39;,\n})\n  .done(function( json ) {\n     $( &#39;&lt;h1&gt;&#39; ).text( json.title ).appendTo( &#39;body&#39; );\n     $( &#39;&lt;div class=\\&#39;content\\&#39;&gt;&#39;).html( json.html ).appendTo( &#39;body&#39; );\n  })\n  .fail(function( xhr, status, errorThrown ) {\n    console.log( &#39;出现错误!&#39; )\n    console.log( &#39;Error: &#39; + errorThrown )\n    console.log( &#39;Status: &#39; + status )\n    console.dir( xhr )\n  })\n  .always(function( xhr, status ) {\n    console.log( &#39;已完成!&#39; )\n  })\n</code></pre><h3 id=\"fetch\">fetch</h3>\n<pre><code>fetch(url).then(response =&gt; response.json())\n  .then(data =&gt; console.log(data))\n  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))\n</code></pre><ul>\n<li><h4 id=\"-fetch\">启用fetch</h4>\n</li>\n</ul>\n<p>由于目前原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ：</p>\n<blockquote>\n<p>由于 IE8 是 ES3，需要引入 ES5 的 polyfill: <a href=\"https://github.com/es-shims/es5-shim\">es5-shim, es5-sham</a></p>\n<p>引入 Promise 的 polyfill: <a href=\"https://github.com/jakearchibald/es6-promise\">es6-promise</a></p>\n<p>引入 fetch 探测库：<a href=\"https://github.com/camsong/fetch-detector\">fetch-detector</a></p>\n<p>引入 fetch 的 polyfill: <a href=\"https://github.com/camsong/fetch-ie8\">fetch-ie8</a></p>\n<p>可选：如果你还使用了 jsonp，引入 <a href=\"https://github.com/camsong/fetch-jsonp\">fetch-jsonp</a></p>\n<p>可选：开启 Babel 的 runtime 模式，现在就使用 async/await</p>\n</blockquote>\n<ul>\n<li><h3 id=\"fetch-\">fetch 常见的坑</h3>\n</li>\n<li><p>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &#39;include&#39;})</p>\n</li>\n<li><p>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</p>\n</li>\n<li><p>Fetch 和标准 Promise 的不足</p>\n</li>\n</ul>\n<blockquote>\n<p>由于 Fetch 是典型的异步场景，所以大部分遇到的问题不是 Fetch 的，其实是 Promise 的。ES6 的 Promise 是基于 Promises/A+ 标准，为了保持 简单简洁 ，只提供极简的几个 API。如果你用过一些牛 X 的异步库，如 jQuery(不要笑) 、Q.js 或者 RSVP.js，可能会感觉 Promise 功能太少了。</p>\n<ul>\n<li>没有 Deferred</li>\n</ul>\n<p>Deferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。\nECMAScript 11 年就有过 Deferred 提案，但后来没被接受。其实用 Promise 不到十行代码就能实现 Deferred：es6-deferred。现在有了 async/await，generator/yield 后，deferred 就没有使用价值了。</p>\n<ul>\n<li>没有获取状态方法：isRejected，isResolved</li>\n</ul>\n<p>标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。</p>\n<ul>\n<li>缺少其它一些方法：always，progress，finally</li>\n</ul>\n<p>always 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。</p>\n<ul>\n<li>不能中断，没有 abort、terminate、onTimeout 或 cancel 方法</li>\n</ul>\n<p>Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题 whatwg/fetch#27</p>\n</blockquote>\n<h4 id=\"-fetch-api-http-bubkoo-com-2015-05-08-introduction-to-fetch-\"><a href=\"http://bubkoo.com/2015/05/08/introduction-to-fetch/\">fetch Api 简介</a></h4>\n<h4 id=\"-\">参考资料</h4>\n<ul>\n<li><p><a href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\">https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/AJAX\">https://zh.wikipedia.org/wiki/AJAX</a></p>\n</li>\n<li><p><a href=\"http://skychang.github.io/2015/11/02/JavaScript-Use_Javascript_Fetch/\">http://skychang.github.io/2015/11/02/JavaScript-Use_Javascript_Fetch/</a></p>\n</li>\n</ul>\n"},{"title":"JavaScript some tips","time":"2016-12-07 10:15","notebook":"JavaScript","_key":10,"id":"20161207","html":"<h1 id=\"some-tips\">some tips</h1>\n<p><em>some tips about JavaScript</em></p>\n<hr>\n<h3 id=\"what-is-the-difference-between-map-every-and-foreach-\">What is the difference between .map, .every, and .forEach?</h3>\n<ul>\n<li><p>.map()</p>\n<blockquote>\n<p>returns a new Array of objects created by taking some action on the original item.</p>\n</blockquote>\n</li>\n<li><p>.every()</p>\n<blockquote>\n<p>returns a boolean - true if every element in this array satisfies the provided testing function. An important difference with .every() is that the test function may not always be called for every element in the array. Once the testing function returns false for any element, no more array elements are iterated. Therefore, the testing function should usually have no side effects.</p>\n</blockquote>\n</li>\n<li><p>.forEach()</p>\n<blockquote>\n<p>returns nothing - It iterates the Array performing a given action for each item in the Array.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"the-test-about-immutable-js\">the test about Immutable.js</h3>\n<blockquote>\n<p>It is not a very good way to add Immutable.js into a part of project.</p>\n</blockquote>\n<ul>\n<li>redux-immutable<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.\nAfter that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable. Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre><hr>\n"}]},{"nid":1,"notebook":"react","data":[{"title":"关于React diff的一些理解","time":"2016-12-13 09:39","notebook":"react","_key":13,"id":"20161213","html":"<h1 id=\"-react-diff-\">关于React diff的一些理解</h1>\n<p>React diff 算法，实际上解决的是将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题</p>\n<blockquote>\n<h3 id=\"diff-\">diff 策略</h3>\n<p>一、 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>\n<p>二、 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</p>\n<p>三、 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>\n</blockquote>\n<h3 id=\"tree-diff\">tree diff</h3>\n<p>tree diff 指的是在前后两个虚拟DOM树比较过程中，只对同一层进行比较，这样子明显只要遍历一遍就行了。它在操作的时候只有删除和添加。</p>\n<p>如果出现了跨层级的移动DOM，就会直接删除它在原来的位置，然后在新的位置重新创建，这样子其实影响了它的性能。所以最好不要进行跨层级移动DOM。</p>\n<h3 id=\"component-diff\">component diff</h3>\n<p>还是进行一层一层的比较。如果出现了一个节点改变了，那么它会替换这个节点和它下面的所有子节点。</p>\n<p>如果设置了shouldComponentUpdate 返回值是false，那么将认定这个节点不变，不去进行diff，节约了时间。</p>\n<h3 id=\"element-diff\">element diff</h3>\n<p>同一层级的节点比较，diff会有三个操作，添加，删除，还有移动。</p>\n<p>在同一层级的diff中会有一个问题，就是先后顺序问题，有时候，其实所有的节点都是原来的节点，只不过是修改了先后顺序而已，这个时候，diff下来肯定是很多对不上的，如果进行删除和添加操作，肯定会影响性能。</p>\n<p>这个时候，就要靠key来帮忙了。当设置了key之后，在diff过程中，会默认将同样的key的节点进行匹配diff。这样就能免去不必要的添加删除操作，只要移动就行了。</p>\n<p>diff的本质，就是通过设置一些规则，让diff算法变得快速直接。</p>\n"},{"title":"我是这样灵活控制redux的state树的","time":"2016-12-10 13:28","notebook":"react","_key":12,"id":"20161210_1","html":"<h1 id=\"-redux-state-\">我是这样灵活控制redux的state树的</h1>\n<blockquote>\n<p>在 <code>Redux</code>的操作中，做一个action往往比较麻烦，要写很多个文件。个人觉得很浪费时间，因为大部分内容只是一些机械的复制粘贴操作。</p>\n<p>所以我做了一个通用的action来非常快速和灵活的发action来改变redux的state树。</p>\n<p>说明一下，整个操作的前提是已经进行了 redux-immutable 改造。否则很难对内层的state数据进行精确操作。</p>\n<p>废话不多说了，上代码。</p>\n</blockquote>\n<ul>\n<li>action.js<blockquote>\n<p>里面已经包含了向后台请求数据的操作。</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import fetch from &#39;isomorphic-fetch&#39;;\nimport {\n    truck\n} from &#39;actions&#39;;\n\nconst BASE_URL = &quot;https://api.jasonff.top/&quot;;\n\nexport const action = ({\n    moduleName,\n    body,\n    url,\n    config,\n    method,\n    goods,\n    unload,\n    callback,\n    query,\n    deepMerge\n}) =&gt; (dispatch) =&gt; {\n\n        const resData = (json) =&gt; {\n            const data = {\n                [`${moduleName}`]: {\n                    loaded: true,\n                    ...json,\n                    ...goods\n                }\n            }\n            truck({data:data,name:`${moduleName}`,deepMerge:deepMerge})(dispatch)\n            if (callback) { // callback的存在，可以在实际使用中没必要在componentWillReceiveProps中做回调操作。可以直接对某个action做异步回调。精确，快速。\n                callback(json)\n            }\n        }\n\n        if (unload) { // unload的目的是在state树中完全卸载这条数据。\n            return truck({data:null,name:`${moduleName}`,unload:true})(dispatch)\n        }\n        if (method &amp;&amp; url) { // 发送异步请求的操作。\n            let cfg = config || {};\n            let _url = url;\n            if (query) { // 支持query操作，没有必要进行url字符串拼接了。\n                let keys;\n                _url = url + &#39;?&#39;;\n                try {\n                    keys = Object.keys(query)\n                } catch (e) {\n                    console.log(e)\n                }\n                for (var i = 0; i &lt; keys.length; i++) {\n                    _url = _url + `${keys[i]}=${query[keys[i]]}&amp;`\n                }\n                _url = _url.replace(/\\&amp;$/,&#39;&#39;)\n\n            }\n            cfg.headers = Object.assign({}, cfg.headers, {\n                &#39;Content-Type&#39;: &#39;application/json&#39;\n            })\n            fetch(BASE_URL+_url,Object.assign({},cfg,{\n                    method: method,\n                    body: JSON.stringify(body)\n            })).then(res =&gt; res.json()).then(json =&gt; resData(json)).catch(ex =&gt; resData(ex))\n        } else {\n            resData({})\n        }\n}\n</code></pre><ul>\n<li>truck.js</li>\n</ul>\n<pre><code>\nconst TRUCK_LOAD = &#39;TRUCK_LOAD&#39;;\nconst TRUCK_UNLOAD = &#39;TRUCK_UNLOAD&#39;;\nconst initialState = Immutable.Map()\n\nconst truck_load = (data,name,deepMerge) =&gt; ({\n        type: TRUCK_LOAD,\n        data: data,\n        name: name,\n        deepMerge: deepMerge\n})\n\nconst truck_unload = (data,name) =&gt; ({\n        type: TRUCK_UNLOAD,\n        name: name\n})\n\nexport default (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case &#39;TRUCK_LOAD&#39;:\n            // 下面是主要的代码来merge发上来的各个action\n            if (action.deepMerge) { // 如果是需要deepMerge的就deepMerge，这个功能可以改变state树中的深层的数据。\n                let an = Immutable.fromJS(action.data);\n                let re = state.mergeDeep(an);\n                return re;\n            }\n            // 下面的代码只merge到第二层，可以进行第二层数据上面的覆盖和替换。\n            let sn = state.get(action.name)||Immutable.Map();\n            let an = Immutable.fromJS(action.data[action.name]);\n            let nv = sn.merge(an);\n            let newAction = Immutable.Map().set(action.name, nv);\n            let re = state.merge(newAction);\n            return re;\n\n        case &#39;TRUCK_UNLOAD&#39;:\n            // 卸载掉了这条数据\n            state.delete(action.name)\n            return state\n        default:\n            return state;\n    }\n}\n\nexport const truck = ({data,name,unload,deepMerge}) =&gt; {\n    if (unload) {\n        return (dispatch)=&gt;{\n            dispatch(truck_unload(null,name))\n        }\n    }\n    return (dispatch)=&gt;{\n        dispatch(truck_load(data,name,deepMerge))\n    }\n}\n</code></pre><h3 id=\"-\">下面是我的使用示例</h3>\n<ul>\n<li>没有异步请求的情况</li>\n</ul>\n<pre><code>this.props.action({\n    moduleName: `Breadcrumb`,\n    goods: {\n        data: [{\n            url:&#39;/&#39;+selectedCity.domain,name:&#39;首页&#39;\n        },{\n            url:`/${selectedCity.domain}/buildings`,name:&#39;写字楼&#39;\n        }]\n    }\n})\n</code></pre><p><img src=\"http://api.jasonff.top/dist/20161210_1_0.png\" alt=\"Paste_Image.png\"></p>\n<ul>\n<li>有异步请求数据的情况</li>\n</ul>\n<pre><code>import React from &#39;react&#39;;\nimport {Message} from &#39;components&#39;;\nconst style = require(&#39;./Collect.scss&#39;);\n\n\nexport default ({action,status,type,id,checkLogin}) =&gt; {\n    let _status = status;\n    const ts = {\n        b: {\n            name: &#39;收藏楼盘&#39;,\n            falseurl: &#39;collections/buildings?buildingId=&#39;+id,\n            trueurl: &#39;collections/buildings?buildingId=&#39;+id,\n            param: function(_s){\n                return {\n                    moduleName: &#39;BuildingDetail&#39;,\n                    goods: {\n                        data: {\n                            collection: !_s\n                        }\n                    },\n                    deepMerge:true\n                }\n            }\n        },\n        r: {\n            name: &#39;收藏房源&#39;,\n            falseurl: &#39;collections/rooms?rooomId=&#39;+id,\n            trueurl: &#39;collections/rooms?rooomId=&#39;+id,\n        },\n        i: {\n            name: &#39;收藏众创空间&#39;,\n            falseurl: &#39;incubator/collect?incubatorId=&#39;+id,\n            trueurl: &#39;incubator/delete_collect?id=&#39;+id,\n            param: function(_s){\n                return {\n                    moduleName: &#39;IncubatorDetail&#39;,\n                    goods: {\n                        data: {\n                            collection: !_s\n                        }\n                    },\n                    deepMerge:true\n                }\n            }\n        }\n    }\n\n    const onClick = () =&gt; {\n        checkLogin()\n        .then(res=&gt;action({\n                moduleName: &quot;Collection&quot;,\n                method: `${_status?&#39;DELETE&#39;:&#39;POST&#39;}`,\n                url: ts[type][_status+&#39;url&#39;],\n                needToken: true,\n                callback: function(data) {\n                    if (data.status == 1) {\n                        try {\n                            const eR = document.getElementById(&quot;collect_e&quot;);\n                            eR.style.opacity = `${_status?1:0}`;\n                        } catch (e) {\n                            console.log(e)\n                        }\n                        try {\n                            const fR = document.getElementById(&quot;collect_f&quot;);\n                            fR.style.opacity = `${_status?0:1}`;\n                        } catch (e) {\n                            console.log(e)\n                        }\n                        Message(&#39;success&#39;,_status?&#39;取消收藏成功！&#39;:&#39;收藏成功！&#39;)\n                        action(ts[type][&quot;param&quot;](_status))\n                    }\n                }\n            })\n        )\n    }\n    return &lt;span onClick={onClick} className={style.container}&gt;\n        &lt;i id=&quot;collect_e&quot; style={{opacity:`${status?0:1}`}} className=&quot;soubanicon&quot;&gt;&lt;/i&gt;\n        &lt;i id=&quot;collect_f&quot; style={{opacity:`${status?1:0}`}} className=&quot;soubanicon&quot;&gt;&lt;/i&gt;\n        &lt;span className={style.title}&gt;{_status?&quot;已收藏&quot;:ts[type].name}&lt;/span&gt;\n    &lt;/span&gt;\n}\n</code></pre><h1 id=\"-\">最后分析一下我的这个方法吧</h1>\n<p>好处就不说了，就是非常快速灵活的发送action，想改什么就改什么。</p>\n<p>坏处：\n一、 难以设置reducer的默认值。数据结构因为太灵活不固定所以难以预测。\n二、不能对于action进行很系统的管理，只有发了之后action才看到它存在，不能在刚开始的时候就知道所有的action。其实跟第一点一样。\n三、每个action没有它们自己的设置。因为他们是被生成出来的。而不是刚开始就定义好的。\n四、其他。。。</p>\n<p>如果有什么建议，马上留言哦。谢谢您的关注。</p>\n"},{"title":"Update My Project With Immutable.js","time":"2016-12-10 10:06","notebook":"react","_key":11,"id":"20161210_0","html":"<h1 id=\"update-my-project-with-immutable-js\">Update My Project With Immutable.js</h1>\n<ul>\n<li>redux-immutable</li>\n</ul>\n<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.</p>\n<p>After that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable.</p>\n<p>Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre>"},{"title":"React单页面应用项目 性能优化 实践","time":"2016-07-19 13:54:58","notebook":"react","_key":7,"id":"20160719","html":"<h1 id=\"react-\">React单页面应用项目 性能优化 实践</h1>\n<p>react 单页面应用项目在加载优化这一块就得依赖webpack的打包方式。\nwebpack的打包优化的本质就是将 bundle.js 拆分方式进行优化。</p>\n<p>目前，就我所知的 bundle.js 的拆分方式有以下几种</p>\n<blockquote>\n<ul>\n<li>按需加载\n这个方式要求在react-router中不能简单的import container，需要用到requier.ensure()方法，具体实践可以参阅相关文档，如果不用require.ensure()，webpack将不会生成很多个chunkfile，也不能实现将 bundle.js 优化的效果。下面是配置代码。</li>\n</ul>\n</blockquote>\n<pre><code>entry: {\n    main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)]\n},\noutput: {\n    path: path.resolve(__dirname, &quot;dist/app&quot;),\n    filename: &#39;bundle.[hash].js&#39;,\n    chunkFilename: &#39;[id].[hash].chunk.js&#39;,\n    publicPath: &#39;/dist/app/&#39;\n}\n</code></pre><blockquote>\n<ul>\n<li>利用webpack插件进行提取一部分内容以压缩 bundle.js\n这个方法具体用到的插件有 ExtractTextPlugin，CommonsChunkPlugin。\n同时在nginx配置中开启gzip。\n下面是配置代码</li>\n</ul>\n</blockquote>\n<pre><code>    entry: {\n      main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)],\n      vendor:[&#39;react&#39;, &#39;redux&#39;] // 将一些比较大的库单独提取出来。\n    },\n    output: {\n        path: path.resolve(__dirname, &quot;dist/app&quot;),\n        filename: &#39;bundle.[hash].js&#39; // 只生成单个bundle.js文件\n    },\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n                warnings: false\n            }\n        }),\n        new ExtractTextPlugin(&#39;[name]-[chunkhash].css&#39;, {allChunks: true}), //用该插件提取所有css样式\n        new webpack.optimize.CommonsChunkPlugin(&#39;vendor&#39;,  &#39;vendor.js&#39;), //将那些库生成 vendor.js\n    ],\n    module: {\n        loaders: [\n            {\n                test: /\\.scss$/,\n                loader: ExtractTextPlugin.extract(&#39;style&#39;,&#39;css?modules&amp;importLoaders=2&amp;sourceMap&amp;localIdentName=[local]___[hash:base64:5]!sass?outputStyle=expanded&amp;sourceMap&#39;)\n            } // 将scss生成的css样式单独提取出来\n        ]\n    },\n</code></pre><blockquote>\n<ul>\n<li>还有就是上面两者的混合配置</li>\n</ul>\n</blockquote>\n<h3 id=\"-\">下面将上述的三种配置进行性能测试</h3>\n<blockquote>\n<p>测试用的是chrome的timeline，并且将项目的各项数据记录了下来</p>\n</blockquote>\n<ol>\n<li>按需加载</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_0.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>提取公共部分与css</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_1.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>混合模式</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_2.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>其实不难看出大部分的时间差异是在scripting和ldle，其他的差异都是几十毫秒而已，二这两项的差异能达到上百毫秒。</p>\n</blockquote>\n<h1 id=\"-\">总结</h1>\n<blockquote>\n<p>最后我对于项目采用何种优化方式进行一下自己的体验和总结。</p>\n<ol>\n<li>如果是小项目 bundle.js 比较小，建议使用提取公共部分与css就行。</li>\n<li>如果是大项目 bundle.js 比较大，建议使用混合模式想方设法减小bundle.js单个文件的大小。</li>\n<li>建议用sass或者less写样式，不使用内联写法，因为最后可以提取出来单独成为css。而内联写法就只能存在于bundle.js之中，增大了bundle.js。</li>\n<li>使用nginx配置，并且开启gzip。</li>\n</ol>\n</blockquote>\n"},{"title":"react modal 的 简单实现 与 原理分析","time":"2016-06-29 16:31:30","notebook":"react","_key":5,"id":"20160629","html":"<h1 id=\"react-modal-\">react modal 的 简单实现 与 原理分析</h1>\n<blockquote>\n<p>在React项目中，由于所有的Component将会被render在body的一个div之中，并且往往是Component包Component，就像一个洋葱一样，一层包着一层，里层的很难触及比较外面的一层。</p>\n<p>可是，在css中，position属性往往被外层的position所左右，height: 100% 往往被外层的height所左右。如何才能做出一个拥有半透明的黑色遮罩，罩住整个页面，从而实现modal的效果呢？</p>\n</blockquote>\n<p>在react 中，modal 的思路就是制作一个<strong><Modal></Modal></strong> Component，但是把它render 到body 的下一层去，而不是跟其他Component 一样render 到Component 的最里层。</p>\n<p>只有render在body的下一层，与现有的Component 组平起平坐，这样才完全脱离的样式局限，当我在<strong><Modal></Modal></strong> 设置样式的时候可以为所欲为。</p>\n<p>在这里就要借助 <strong>react-dom</strong> 了。因为render方法是 <strong>react-dom</strong> 提供的；\n下面将是我测试的代码。</p>\n<pre><code>import React, {Component, PropTypes} from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\n\nexport default class Modal extends Component {\n    static defaultProps = {\n        open: false\n    };\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.open &amp;&amp; !this.props.open) { // 从无到有\n            this.node = document.createElement(&#39;div&#39;); // 创建 DOM\n            this.node.className = &#39;ReactModal&#39;; // 给上 ClassName\n            document.getElementsByTagName(&#39;body&#39;)[0].appendChild(this.node) // 给 body 加上刚才的 带有 className 的 div\n            // 这个时候创建了 render的目的地。\n            const style = require(&#39;./style.scss&#39;); // css 样式\n            const {children, ...rest} = nextProps;\n            let modal = (\n                &lt;div className={style.container}&gt;\n                    &lt;div className={style.mask} {...rest}&gt;&lt;/div&gt;\n                    {nextProps.children}\n                &lt;/div&gt;\n            );\n            // 这个时候创建了 Modal 的虚拟 Dom\n            let allClass = document.getElementsByClassName(&#39;ReactModal&#39;);\n            ReactDOM.render(modal, allClass[allClass.length - 1]) // 之所以这么写，是因为能重复打开Modal，因为每一次打开Modal，都会建立一个div\n            // 将 Modal 成功 render 到目的地\n        }\n        if (this.props.open &amp;&amp; !nextProps.open) { // 从有到无\n            ReactDOM.unmountComponentAtNode(this.node) // 调用 react-dom unmountComponentAtNode方法，将Modal解除。\n            // 或者可以写下面的方法，将整个创建的div删除，这样多次打开就不会有很多个div残留在body中，但是并不是很正规的做法。\n            // document.getElementsByTagName(&#39;body&#39;)[0].removeChild(document.getElementsByClassName(&#39;ReactModal&#39;)[0])\n        }\n    }\n    render() {\n        return null // 只要这个Component的方法，不要它的render，它的render将会render到内层。\n    }\n}\n</code></pre><p><img src=\"http://api.jasonff.top/dist/20160629_0.png\" alt=\"Paste_Image.png\"></p>\n<p>选中处为刚添加的dom，它被正确的render到body下一层，与<strong> #content </strong>平起平坐，里面有内容，上面的div为多次打开关闭Modal之后残留的div。</p>\n"},{"title":"react server rendering","time":"2016-05-25 17:05:30","notebook":"react","_key":1,"id":"20160525","html":"<h1 id=\"react-server-rendering-\">react server rendering（服务端渲染）</h1>\n<p><em>一个react项目在服务器端渲染，其实最本质的一个点就在于路由。路由一般采用的是<code>react-router</code>。其实在<code>react-router</code>里，它本身就提供了服务器端渲染的方法，下面对它进行一下小小的学习。</em></p>\n<p>服务端渲染跟客户端渲染有点不同，因为，服务端渲染需要发送500/30x，还要在渲染前就要请求数据。</p>\n<p><code>react-router</code>提供了两个更底层的api，一个是<code>match</code>，另一个是<code>RouterContext</code>。</p>\n<p><code>match</code>是用来匹配路由的，但是它没有渲染的功能。\n<code>RouterContext</code>用来同步渲染components的。</p>\n<p>看个例子：</p>\n<pre><code>import { renderToString } from &#39;react-dom/server&#39;\nimport { match, RouterContext } from &#39;react-router&#39;\nimport routes from &#39;./routes&#39;\nserve((req, res) =&gt; {\n    match({ routes, location: req.url }, (error, redirectLocation, renderProps) =&gt; {\n        if (error) {\n            res.status(500).send(error.message)\n        } else if (redirectLocation) {\n            res.redirect(302, redirectLocation.pathname + redirectLocation.search)\n        } else if (renderProps) {\n            res.status(200).send(renderToString(&lt;RouterContext {...renderProps} /&gt;))\n        } else {\n            res.status(404).send(&#39;Not found&#39;)\n        }\n    })\n})\n</code></pre><p>这是一个非常简单的在服务端渲染例子，但是现在一个最重要的问题，就是如何传数据呢？</p>\n<p>在react项目中，一般是用redux来进行数据的管理的。redux 里有个store维护的state状态树。那么在和api进行数据交互的时候，如何将数据放在store里面呢？</p>\n<p>基本的思路就是，在createStore的时候，将与api交互的方法同时传入进去，这样，在store中的action可以调用那个库。调用库去请求数据，一般是个promise对象，取到数据之后，然后在reducer中将数据reduce进state树中。就完成了这个过程。</p>\n<p>其实最最本质的，就是让action能去api请求数据，只要action请求到了数据并且能进入reducer，那就成功了。这个思路跟客户端渲染也没有什么区别。</p>\n<p>在服务端渲染还有一个致命的报错。来自于webpack。</p>\n<p>在client，webpack可以require()各种静态资源，但是在node 环境中,require()是只能用于javascript 的。</p>\n<p>这里就要靠一个library了。\n<a href=\"https://github.com/halt-hammerzeit/webpack-isomorphic-tools\">webpack-isomorphic-tools</a>\n具体的介绍在github中都有，也不在这里赘述。</p>\n<p>另外再向大家推荐一个完整的react例子，里面有很多很多东西可以参考借鉴，甚至可以直接拿过来做自己的项目。\n<a href=\"https://github.com/erikras/react-redux-universal-hot-example\">react栗子</a></p>\n"},{"title":"react-router 笔记","time":"2016-05-11 17:16:30","notebook":"react","_key":0,"id":"20160511","html":"<h1 id=\"react-router-\">react-router 笔记</h1>\n<h4 id=\"-hashhistory-\"><strong><code>hashHistory</code>什么用？</strong></h4>\n<p>它控制着带着hash值的路由，比如说有两个路由</p>\n<pre><code>  &lt;Router history={hashHistory}&gt;\n    &lt;Route path=&quot;/&quot; component={App}/&gt;\n    {/* add the routes here */}\n    &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n    &lt;Route path=&quot;/about&quot; component={About}/&gt;\n  &lt;/Router&gt;\n</code></pre><p>现在去访问的话通过hash值比如\n<code>localhost:8080/#/about</code>\n<code>localhost:8080/#/repos</code>\n那我不想出现那个#呢？\n那就用<code>browserHistory</code></p>\n<h4 id=\"-link-a-\"><strong> Link 和 a 标签的区别</strong></h4>\n<p>其中一个区别是标记active。这个在导航的时候特别管用。\n以往，想要标记active需要操作dom给导航添加class或者style。\n<code>Link</code>标签提供了两个接口 <code>activeStyle</code> 和 <code>activeClassName</code> 在<code>Link</code> active的时候自动变换样式。\n<code>Link</code> 是 <code>react-router</code>内部的跳转，<code>a</code> 是浏览器的跳转。</p>\n<h4 id=\"-\"><strong>组件传参的技巧</strong></h4>\n<p>以前在传参数的时候，总会在组件中定义一些东西，比如<code>handleChange</code>、<code>handleClick</code>啊什么的。甚至在拿数据的时候还传了<code>handleRef</code>。\n现在经过观看别人的项目，我发现几个更好的解决方案。\n第一个，如何传一些<code>onChange</code>什么的参数。很简单，<code>{...this.props}</code>然后在父级的时候，传<code>onChange()</code>。传什么就进来什么，每个组件的可定义度很高。\n第二个，如何传<code>input</code>中的数据，用<code>event</code>，在<code>onChange</code>事件中，可以传<code>event</code>，然后通过<code>event.target</code>来获取<code>input</code>的DOM。so easy!</p>\n<h4 id=\"-url-\"><strong> 关于url中传参的问题</strong></h4>\n<p>比如，我想打开</p>\n<pre><code>/repos/reactjs/react-router\n/repos/facebook/react\n</code></pre><p>怎么整？\n它其实在url中传了两个参数，我们暂且定义成这样</p>\n<pre><code>/repos/:userName/:repoName\n</code></pre><p>第一、路由怎么写？</p>\n<pre><code> &lt;Route path=&quot;/repos/:userName/:repoName&quot; component={Repo}/&gt;\n</code></pre><p>第二、Link怎么写？</p>\n<pre><code> &lt;Link to=&quot;/repos/reactjs/react-router&quot;&gt;React Router&lt;/Link&gt;\n</code></pre><p>第三、如何在页面中取到参数？</p>\n<pre><code> &lt;h2&gt;{this.props.params.repoName}&lt;/h2&gt;\n</code></pre><p>这个其实还挺简单的。</p>\n<h4 id=\"-js-\"><strong>关于用js来实现页面路由跳转问题</strong></h4>\n<p>在react-router中，据我所知，有两种方法。\n第一种，使用withRouter()，然后将在内部可以获取this.props.router。\n第二种，使用this.context.router，不过在使用前必须定义这个类的contextTypes。</p>\n<p>withRouter怎么用？</p>\n<pre><code> ...\n import {withRouter} from &#39;react-router&#39;\n class Abc extends Component {\n                  ...\n       this.props.router.push(&#39;/&#39;)\n}\nexport default withRouter(Abc)\n</code></pre><p>用context怎么用？</p>\n<pre><code> ...\nexport default class Abc extends Component {\n                  ...\n       this.context.router.push(&#39;/&#39;)\n}\nAbc.contextTypes = {\n       router: React.PropsTypes.object\n}\n</code></pre>"}]},{"nid":2,"notebook":"node","data":[{"title":"JasonFF 静态博客的一些总结","time":"2016-11-28 20:54:12","notebook":"node","_key":9,"id":"20161127","html":"<h1 id=\"jasonff-\">JasonFF 静态博客的一些总结</h1>\n<h2 id=\"-markdown-json-\">一、将 markdown 编译为json格式</h2>\n<pre><code>var fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\nvar marked = require(&#39;marked&#39;);\nvar request = require(&#39;request&#39;);\nvar downloadPic = require(&#39;./widgets/downloadPic&#39;);\n\nfunction MarkdownReader(options) {\n    this.from = options.from;\n    this.to = options.to;\n    this.rule = /\\.md$/;\n}\n\nMarkdownReader.prototype.apply = function() {\n    var that = this;\n    try {\n        fs.readdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    } catch (e) {\n        fs.mkdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    }\n\n    fs.readdir(that.from, function(error, files) {\n        if (error) {\n            console.error(error)\n        }\n        var mddata = new Array();\n        var notebook = new Array();\n\n        for (var i = 0; i &lt; files.length; i++) {\n            if (that.rule.test(files[i])) {\n                var article;\n                try {\n                    article = that._getArticle(files[i], i);\n                    mddata.push(article)\n                } catch (e) {\n                    console.log(e)\n                }\n\n            }\n        }\n        fs.writeFileSync(path.join(that.to, &#39;data.json&#39;), JSON.stringify(mddata.reverse()))\n        fs.writeFileSync(path.join(that.to, &#39;notebook.json&#39;), JSON.stringify(that._getNotebook(mddata)))\n    })\n}\n\n\nMarkdownReader.prototype._getArticle = function(files, index) {\n    var that = this;\n    var fileInfo;\n    var _path = path.join(that.from, files);\n    var fileText = fs.readFileSync(path.join(that.from, files)).toString()\n    var configText = fileText.substring(0, fileText.indexOf(&#39;}&#39;) + 1)\n    var markdownText = fileText.substring(fileText.indexOf(&#39;}&#39;) + 1);\n    var markdownText = this._getPic(markdownText,files)\n    var fileInfo = fs.statSync(_path)\n\n    try {\n        var config = JSON.parse(configText)\n    } catch (e) {\n        console.error(e);\n    }\n    if (!config) {\n        console.error(files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot;)\n        console.log(&quot;请在 &quot; + files + &quot; 开头添加JSON格式的信息！参照栗子！请注意JSON的语法！请不要在JSON中写对象！！&quot;)\n        console.log(&quot;你看看你写的什么 &quot; + configText)\n        return false\n    }\n    config._key = index;\n    config.id = files.replace(&#39;.md&#39;, &#39;&#39;);\n    var markdownHTML = marked(markdownText);\n    config.html = markdownHTML;\n\n    return config\n}\n\nMarkdownReader.prototype._getNotebook = function(config) {\n    var result = new Array();\n    var nid = 0;\n    for (var i = 0; i &lt; config.length; i++) {\n        for (var m = 0; m &lt; result.length; m++) {\n            var ifMatch = false;\n            if (result[m].notebook == config[i].notebook) {\n                result[m].data.push(config[i]);\n                ifMatch = true;\n                break\n            }\n        }\n        if (!ifMatch) {\n            result.push({\n                nid: nid,\n                notebook: config[i].notebook,\n                data: [config[i]]\n            })\n            nid++\n        }\n    }\n    return result;\n}\n\nMarkdownReader.prototype._getPic = function(md,filename) {\n    var result,urls;\n    var _md = md;\n    try {\n        result = _md.match(/\\!\\[[^\\]]+\\]\\([^\\)]+\\)/ig)\n    } catch (e) {}\n    if (result) {\n        urls = result.map(function(item,i){\n            return /\\([^\\)]+\\)/ig.exec(item)[0].replace(/^\\(/,&#39;&#39;).replace(/\\)$/,&#39;&#39;)\n        })\n    }\n    if (urls) {\n        var basePath = path.join(__rootPath,&#39;/dist&#39;);\n        for (var i = 0; i &lt; urls.length; i++) {\n            var imgName = filename.replace(&#39;.md&#39;,&#39;&#39;)+&#39;_&#39;+i+&#39;.png&#39;;\n            downloadPic(urls[i],basePath,imgName)\n            _md = _md.replace(urls[i],&#39;http://api.jasonff.top/dist/&#39;+imgName)\n        }\n    }\n    return _md\n}\n\nmodule.exports = MarkdownReader;\n</code></pre><ul>\n<li>图片插入的解决方案\n如果按照markdown的语法进入插入图片，显得太麻烦了，人活着就是为了偷懒，怎么样才能快速将图片插入我的markdown文档中呢？\n我发现简书的插入图片特别的方便，直接在编辑器中粘贴就把图片给插入进去了。但是我的编辑环境是atom 啊。难不成自己写个atom插件？\natom插件貌似也是可行的。但是我发现一个特别偷懒的办法，我不是可以获取简书的图片地址吗？我可以把图片借助简书给下到指定文件夹。\n下面就是代码</li>\n</ul>\n<pre><code>var path = require(&#39;path&#39;);\nvar request = require(&#39;request&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar download = function(uri, dir,filename){\n    console.log(&#39;start+++&#39;+uri)\n    request.head(uri, function(err, res, body){\n        request(uri).pipe(fs.createWriteStream(dir + &quot;/&quot; + filename));\n    });\n};\n\nmodule.exports = download;\n</code></pre><blockquote>\n<p>这个就是写的下载图片到本地文件夹的一个方法。插入到markdown文件中已经在最上面的代码中体现。</p>\n</blockquote>\n<h2 id=\"-nginx-\">二、nginx 静态代理</h2>\n<p>这个时候，我已经把markdown文档转为了json格式，并且进行了编译。我把图片也已经下载到了指定的文件夹。我现在就需要将这些资源给送出去给我的前端web app。这里用依靠nginx啦！</p>\n<pre><code>server {\n    listen       80;\n    server_name  api.jasonff.top 127.0.0.1;\n\n    root /home/ubuntu/github/jasonff-api;\n\n    gzip on;\n    location ~ \\.json$ {\n        if ($request_method = &#39;OPTIONS&#39;) {\n            add_header Access-Control-Allow-Origin *;\n            add_header Access-Control-Allow-Credentials true;\n            add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n            return 200;\n        }\n\n        if ($request_method = &#39;POST&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n\n        if ($request_method = &#39;GET&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n    }\n\n}\n</code></pre><h2 id=\"-\">三、博客前端部分</h2>\n<blockquote>\n<p>前端部分没什么好说的，主要是react的一些东西。有关于react的总结，我将会有另外的笔记。</p>\n</blockquote>\n"},{"title":"微信JS-SDK(express 实践)","time":"2016-06-01 15:48:30","notebook":"node","_key":2,"id":"20160601","html":"<h1 id=\"-js-sdk-express-\">微信JS-SDK(express 实践)</h1>\n<p>在这里我记录一下用node express配置微信开发的一些代码</p>\n<p>简单的三个页面</p>\n<pre><code>app.use(&#39;/&#39;, routes);\napp.use(&#39;/users&#39;, users);\napp.use(&#39;/login&#39;, login);\n</code></pre><h3 id=\"routes\">routes</h3>\n<p>这个页面我做的是 <strong>用户同意授权，获取code</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\n/* GET home page. */\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var redirect_uri = &quot;http%3A%2F%2Fwww.frombottomto.top/login&quot;;\n    var scope = &#39;snsapi_userinfo&#39;;//两种方式\n    var state = &#39;STATE&#39;;//非必须\n\n    var url = &#39;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#39;+appid+&#39;&amp;redirect_uri=&#39;+redirect_uri+&#39;&amp;response_type=code&amp;scope=&#39;+scope+&#39;&amp;state=&#39;+state+&#39;#wechat_redirect&#39;;\n    res.redirect(url);\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"login\">login</h3>\n<p>这个页面获取的是 <strong>拉取用户信息</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var code = req.query.code;\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var url = &#39;https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#39;+appid+&#39;&amp;secret=6841a50bd9b6e99c77d0e052e5e5eb2a&amp;code=&#39;+code+&#39;&amp;grant_type=authorization_code&#39;;\n\n    //获取code后，请求以下链接获取access_token：  https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code\n    //获取json后get: https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN\n\n    fetch(url).then(function(res){\n        return res.json()\n    }).then(function(json){\n        var accesstoken = json.access_token;\n        var openid = json.openid;\n        var tokenurl = &#39;https://api.weixin.qq.com/sns/userinfo?access_token=&#39;+accesstoken+&#39;&amp;openid=&#39;+openid+&#39;&amp;lang=zh_CN &#39;;\n        return fetch(tokenurl).then(function(res){\n            return res.json()\n        })\n    }).then(function(json){\n        res.send(json)\n    })\n\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"users\">users</h3>\n<p>这个页面获取的是<strong> JS-SDK的 signature</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\nvar sha1 = require(&#39;sha1&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var aturl = &#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#39;+appid+&#39;&amp;secret=&#39;+secret;\n    var access_token;\n\n    fetch(aturl).then(function(res){\n        return res.json()\n    }).then(function(json){\n        access_token = json.access_token;\n        var ticketurl = &#39;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&#39;+access_token+&#39;&amp;type=jsapi&#39;\n        //https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi\n\n        var jsticket;\n        fetch(ticketurl).then(function(res){\n            return res.json()\n        }).then(function(json){\n            jsticket = json.ticket;\n            console.log(req.originalUrl)\n            var string1 = &#39;jsapi_ticket=&#39;+jsticket+&#39;&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://www.frombottomto.top&#39;+req.originalUrl;\n            var signature = sha1(string1);\n            res.render(&#39;users&#39;,{signature:signature})\n        })\n\n    })\n    //https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\n});\n\nmodule.exports = router;\n</code></pre><p>另外前端渲染页面，记录的是调取微信api</p>\n<h3 id=\"users-ejs\">users.ejs</h3>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;微信js测试&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;link rel=&#39;stylesheet&#39; href=&#39;/stylesheets/style.css&#39; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;你好&lt;/h1&gt;\n    &lt;p&gt;Welcome to 微信&lt;/p&gt;\n    &lt;img src=&quot;/image/jf.png&quot; alt=&quot;&quot;&gt;\n    &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        wx.config({\n            debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n            appId: &#39;wx9bf16c912ddec096&#39;, // 必填，公众号的唯一标识\n            timestamp: 1414587457, // 必填，生成签名的时间戳\n            nonceStr: &#39;Wm3WZYTPz0wzccnW&#39;, // 必填，生成签名的随机串\n            signature: &#39;&lt;%= signature %&gt;&#39;,// 必填，签名，见附录1\n            jsApiList: [&#39;onMenuShareTimeline&#39;,&#39;onMenuShareAppMessage&#39;] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2\n        });\n        wx.ready(function(){\n            wx.onMenuShareTimeline({\n                title: &#39;JasonFF&#39;, // 分享标题\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n            wx.onMenuShareAppMessage({\n                title: &#39;JasonFF&#39;, // 分享标题\n                desc: &#39;JasonFF的主页&#39;, // 分享描述\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                type: &#39;link&#39;, // 分享类型,music、video或link，不填默认为link\n                dataUrl: &#39;&#39;, // 如果type是music或video，则要提供数据链接，默认为空\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n        })\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"}]},{"nid":3,"notebook":"服务器","data":[{"title":"linux 虚拟内存实践","time":"2016-11-16 21:41:58","notebook":"服务器","_key":8,"id":"20161116","html":"<h1 id=\"linux-\">linux 虚拟内存实践</h1>\n<ul>\n<li><p>查看 Swap 大小</p>\n<pre><code>free -m\n</code></pre></li>\n<li><p>创建一个 Swap 文件</p>\n<pre><code>mkdir swap\ncd swap\nsudo dd if=/dev/zero of=swapfile bs=1024 count=100000\n</code></pre><blockquote>\n<p>count 代表文件的大小</p>\n</blockquote>\n</li>\n<li><p>把生成的文件转换成 Swap 文件</p>\n<pre><code>sudo mkswap swapfile\n</code></pre></li>\n<li><p>激活 Swap 文件</p>\n<pre><code>sudo swapon swapfile\n</code></pre><blockquote>\n<p>再次查看 free -m 发现添加成功了</p>\n</blockquote>\n</li>\n<li><p>卸载 Swap</p>\n<pre><code>sudo swapoff swapfile\n</code></pre><blockquote>\n<p>进入刚才那个目录</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"React 静态页面 nginx 配置 小白专用","time":"2016-06-15 20:50:30","notebook":"服务器","_key":3,"id":"20160615","html":"<h1 id=\"react-nginx-\">React 静态页面 nginx 配置 小白专用</h1>\n<h3 id=\"-\">第一步：安装</h3>\n<ol>\n<li><a href=\"http://nginx.org/en/download.html\">http://nginx.org/en/download.html</a> 下载</li>\n<li><code>tar -xf nginx-1.2.0.tar.gz</code></li>\n<li>进入解压目录  <code>chmod a+rwx *</code></li>\n<li><code>./configure --without-http_rewrite_module</code></li>\n<li><code>make &amp;&amp; make install</code></li>\n<li><code>sudo /usr/local/nginx/sbin/nginx</code></li>\n<li>浏览器访问 localhost</li>\n<li>惊奇地发现欢迎页面</li>\n</ol>\n<h3 id=\"-\">第二步：基本操作</h3>\n<ul>\n<li>启动<pre><code>cd /usr/local/nginx/sbin\n./nginx\n</code></pre></li>\n<li>软链接\n启动那么麻烦，我想直接打nginx启动！<pre><code>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx\n</code></pre></li>\n<li>查看启动的配置文件\n<code>sudo nginx -t</code></li>\n<li>重启\n<code>sudo nginx -s reload</code></li>\n<li>关闭<pre><code>ps -ef | grep nginx\nkill -QUIT xxxx\n</code></pre></li>\n</ul>\n<h2 id=\"-react-nginx-\">第三步 React 静态页面 nginx 配置 简洁版</h2>\n<pre><code>worker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       8080;\n        server_name  localhost;\n\n        root /Users/jasonff/project/erp-web;\n\n        location / {\n            try_files $uri @fallback;\n        }\n\n        location @fallback {\n            rewrite .* /index.html break;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n    include servers/*;\n}\n</code></pre><h3 id=\"-\">若干解释：</h3>\n<ul>\n<li>我的配置文件在哪里？\n想知道自己的配置文件在哪里，查看第二步中的查看启动配置文件，然后将需要的配置写在这个文件里面。</li>\n</ul>\n<h2 id=\"-\">第四步：多个站点布置</h2>\n<p>在nginx.conf 文件所在目录中，新建一个文件夹 vhost ，新建若干个文件，例如 example1.conf 、 example2.conf ……</p>\n<pre><code>server {\n    listen       8030;\n    server_name  localhost;\n    root /Users/jasonff/project/souban-website;\n    location / {\n        try_files $uri @fallback;\n    }\n    location @fallback {\n        rewrite .* /index.html break;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n}\n</code></pre><p>然后重新配置nginx.conf</p>\n<pre><code>worker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    include        vhosts/*;\n    //加入include vhosts/*\n}\n</code></pre><h3 id=\"-\">附录：配置介绍（字典查询）</h3>\n<pre><code>#运行用户\nuser nobody;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes  1;\n\n#全局错误日志及PID文件\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n#工作模式及连接数上限\nevents {\n    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,\n    #仅用于linux2.6以上内核,可以大大提高nginx的性能\n    use   epoll;\n\n    #单个后台worker process进程的最大并发链接数    \n    worker_connections  1024;\n\n    # 并发总数是 worker_processes 和 worker_connections 的乘积\n    # 即 max_clients = worker_processes * worker_connections\n    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么\n    # 为什么上面反向代理要除以4，应该说是一个经验值\n    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000\n    # worker_connections 值的设置跟物理内存大小有关\n    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数\n    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右\n    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：\n    # $ cat /proc/sys/fs/file-max\n    # 输出 34336\n    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内\n    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置\n    # 使得并发总数小于操作系统可以打开的最大文件数目\n    # 其实质也就是根据主机的物理CPU和内存进行配置\n    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。\n    # ulimit -SHn 65535\n\n}\n\n\nhttp {\n    #设定mime类型,类型由mime.type文件定义\n    include    mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  logs/access.log  main;\n\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\n    #对于普通应用，必须设为 on,\n    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\n    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n    sendfile     on;\n    #tcp_nopush     on;\n\n    #连接超时时间\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    tcp_nodelay     on;\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6].&quot;;\n\n    #设定请求缓冲\n    client_header_buffer_size    128k;\n    large_client_header_buffers  4 128k;\n\n\n    #设定虚拟主机配置\n    server {\n        #侦听80端口\n        listen    80;\n        #定义使用 www.nginx.cn访问\n        server_name  www.nginx.cn;\n\n        #定义服务器的默认网站根目录位置\n        root html;\n\n        #设定本虚拟主机的访问日志\n        access_log  logs/nginx.access.log  main;\n\n        #默认请求\n        location / {\n\n            #定义首页索引文件的名称\n            index index.php index.html index.htm;  \n\n        }\n\n        # 定义错误提示页面\n        error_page   500 502 503 504 /50x.html;\n        location = /50x.html {\n        }\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n\n            #过期30天，静态文件不怎么更新，过期可以设大一点，\n            #如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        }\n\n        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\n        location ~ .php$ {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n            include fastcgi_params;\n        }\n\n        #禁止访问 .htxxx 文件\n            location ~ /.ht {\n            deny all;\n        }\n\n    }\n}\n</code></pre><p>附上我的图片</p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_0.png\" alt=\"Paste_Image.png\"></p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_1.png\" alt=\"Paste_Image.png\"></p>\n"}]},{"nid":4,"notebook":"html&css","data":[{"title":"css3 转盘抽奖实践(sass)","time":"2016-07-07 20:29:58","notebook":"html&css","_key":6,"id":"20160707","html":"<h1 id=\"css3-sass-\">css3 转盘抽奖实践(sass)</h1>\n<blockquote>\n<p>转盘抽奖，就是像这样子的转盘。（如下图）\n点击中间的“点击抽奖”按钮，然后后面的圆形转盘开始转动，最后停在所在结果里。</p>\n</blockquote>\n<p><img src=\"http://api.jasonff.top/dist/20160707_0.png\" alt=\"Paste_Image.png\"></p>\n<h2 id=\"-\">如何实现旋转并且让指针指向目标区域？</h2>\n<blockquote>\n<p>我这里的思路是用css3的一些功能，为了能够写的便捷，我用了sass工具进行编译。</p>\n</blockquote>\n<pre><code>\n$get1: - (120deg+180deg)/2 + 5400deg;\n$get2: - (225deg+180deg)/2 + 5400deg;\n$get5: - (225deg+270deg)/2 + 5400deg;\n$get10: - (45deg+90deg)/2 + 5400deg;\n$get20: - (0deg+45deg)/2 + 5400deg;\n$get50: - (360deg+334deg)/2 + 5400deg;\n$get100: - (308deg+334deg)/2 + 5400deg;\n\n// 这里的角度，都是转盘图片中，各个区域的角度，最终将指针指向每个扇形的中心。\n// 5400deg 是转的圈数\n\n$timing: cubic-bezier(0,0,0,1);\n\n@mixin transformRotate($deg) {\n  transform:rotate($deg);\n  -ms-transform:rotate($deg); /* Internet Explorer */\n  -moz-transform:rotate($deg); /* Firefox */\n  -webkit-transform:rotate($deg); /* Safari 和 Chrome */\n  -o-transform:rotate($deg); /* Opera */\n}\n@mixin getAnimation($attribute) {\n  animation: #{$attribute};\n  -moz-animation: #{$attribute};    /* Firefox */\n  -webkit-animation: #{$attribute};    /* Safari 和 Chrome */\n  -o-animation: #{$attribute};    /* Opera */\n}\n\n@mixin keyframes($animationname, $get) {\n  @keyframes #{$animationname}\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-moz-keyframes #{$animationname} /* Firefox */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-webkit-keyframes #{$animationname} /* Safari 和 Chrome */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-o-keyframes #{$animationname} /* Opera */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n}\n\n@include keyframes(Kget1, $get1);\n@include keyframes(Kget2, $get2);\n@include keyframes(Kget5, $get5);\n@include keyframes(Kget10, $get10);\n@include keyframes(Kget20, $get20);\n@include keyframes(Kget50, $get50);\n@include keyframes(Kget100, $get100);\n\n.get1 {\n  @include getAnimation(&#39;Kget1 10s #{$timing} forwards&#39;);\n}\n// forwards 属性是为了在动画结束的时候不再跳回初始的状态\n.get2 {\n  @include getAnimation(&#39;Kget2 10s #{$timing} forwards&#39;);\n}\n.get5 {\n  @include getAnimation(&#39;Kget5 10s #{$timing} forwards&#39;);\n}\n.get10 {\n  @include getAnimation(&#39;Kget10 10s #{$timing} forwards&#39;);\n}\n.get20 {\n  @include getAnimation(&#39;Kget20 10s #{$timing} forwards&#39;);\n}\n.get50 {\n  @include getAnimation(&#39;Kget50 10s #{$timing} forwards&#39;);\n}\n.get100 {\n  @include getAnimation(&#39;Kget100 10s #{$timing} forwards&#39;);\n}\n</code></pre><h2 id=\"-cubic-bezier-\">下面主要对 cubic-bezier 属性进行一些注释</h2>\n<p><img src=\"http://api.jasonff.top/dist/20160707_1.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>cubic-bezier即为贝兹曲线中的绘制方法。图上有四点，P0-3，其中P0、P3是默认的点，对应了[0,0], [1,1]。而剩下的P1、P2两点则是我们通过cubic-bezier()自定义的。cubic-bezier(x1, y1, x2, y2) 为自定义，x1,x2,y1,y2的值范围在[0, 1]。\n    预留的几个特效：\n    ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)\n    linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)\n    ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)\n    ease-out: cubic-bezier(0, 0, 0.58, 1.0)\n    ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)\n也就是说第四个n是y2，和x2共同决定P2的位置</p>\n</blockquote>\n"}]},{"nid":5,"notebook":"数据库","data":[{"title":"我的mongodb操作手册","time":"2016-06-28 21:04:30","notebook":"数据库","_key":4,"id":"20160628","html":"<h1 id=\"-mongodb-\">我的mongodb操作手册</h1>\n<h2 id=\"-\">准备</h2>\n<ul>\n<li><p>下载</p>\n<pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>解压</p>\n<pre><code>tar -xvf mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>将mongodb中的bin 加入 $PATH</p>\n</li>\n</ul>\n<h2 id=\"-mongod-\">第一部分：mongod 的配置</h2>\n<blockquote>\n<p>mongod是mongodb主要的后台进程，它用来处理数据请求，管理数据存取，执行后台管理操作。在平常的使用中，一般通过一个config文件来管理数据库的行为。</p>\n</blockquote>\n<ul>\n<li>简单的配置\n<strong> myblog.conf</strong><pre><code>port = 27017\ndbpath = db\nlogpath = log/myblog.txt\nrest = true\n</code></pre></li>\n<li>启动 mongd<pre><code>sudo mongod --config myblog.conf\n</code></pre></li>\n</ul>\n<p>加入 --fork 进行后台运行</p>\n<p><em>是在那个配置文件的同一个目录中</em></p>\n<h2 id=\"-mongodb-shell-\">第二部分：mongodb shell 的命令</h2>\n<p>1、查询本地所有数据库名称        </p>\n<blockquote>\n<p>show dbs;</p>\n</blockquote>\n<p>2、切换至指定数据库环境（若无指定的数据库，则创建新的库）</p>\n<blockquote>\n<p>use mydb;</p>\n</blockquote>\n<p>3、查询当前库下的所有聚集集合collection（相当于table）</p>\n<blockquote>\n<p>show collections;</p>\n</blockquote>\n<p>4、创建聚集集合</p>\n<blockquote>\n<p>db.createCollection(&#39;mycollection&#39;);</p>\n</blockquote>\n<p> 5、查询聚集集合中数据条数</p>\n<blockquote>\n<p>db.mycollection.count();</p>\n</blockquote>\n<p>6、插入数据</p>\n<blockquote>\n<p>db.mycollection.insert({&#39;username&#39;:&#39;xyz_lmn&#39;,&#39;age&#39;:26,&#39;salary&#39;:120});</p>\n</blockquote>\n<p><em>往&#39;mycollection&#39;聚集集合中插上一条数库，name为&#39;xyz_lmn&#39;,age为&#39;26&#39;,salary为&#39;120&#39;</em></p>\n<p>7、查询age等于26的数据</p>\n<blockquote>\n<p>db.mycollection.find({&quot;age&quot;:<strong>26</strong>});</p>\n</blockquote>\n<p>8、查询salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>9、查询age小于30，salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({age:{$lt:<strong>30</strong>}},{salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>10、查询salary小于40或salary大于200的数据</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:200}}]});</p>\n</blockquote>\n<p>11、查询指定列的数据</p>\n<blockquote>\n<p>db.mycollection.find({},{age:<strong>1</strong>,salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>1表示显示此列的意思，也可以用true表示     12、查询username中包含&#39;e&#39;的数据</em></p>\n<blockquote>\n<p>db.mycollection.find({username:/e/});</p>\n</blockquote>\n<p>13、查询以a打头的数据</p>\n<blockquote>\n<p>db.mycollection.find({username:/^a/});</p>\n</blockquote>\n<p>14、查询age列数据，并去掉重复数据</p>\n<blockquote>\n<p>db.mycollection.distinct(&#39;age&#39;);</p>\n</blockquote>\n<p>15、查询前10条数据</p>\n<blockquote>\n<p>db.mycollection.find().limit(<strong>10</strong>);</p>\n</blockquote>\n<p>16、查询1条以后的所有数据</p>\n<blockquote>\n<p>db.mycollection.find().skip(<strong>1</strong>);</p>\n</blockquote>\n<p>17、查询第一条数据</p>\n<blockquote>\n<p>db.mycollection.findOne();</p>\n</blockquote>\n<p>18、查询结果集的记录数（查询salary小于40或大于100的记录数）</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:100}}]}).count();</p>\n</blockquote>\n<p>19、按salary升序排序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段升序排序</em>\n20、降序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:-<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段降序排序</em>\n21、根据username修改age</p>\n<blockquote>\n<p>db.employee.update({username:&#39;jim&#39;},{$set:{age:<strong>22</strong>}},false,true);</p>\n</blockquote>\n<pre><code>db.collection.update( criteria, objNew, upsert, multi )\ncriteria : update的查询条件，类似sql update查询内where后面的\nobjNew   : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\nupsert   : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\nmulti    : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n</code></pre><p>22、将指定username的age字段增加5</p>\n<blockquote>\n<p>db.mycollection.update({username:&#39;jim&#39;},{$inc:{age:<strong>5</strong>}},false,true);</p>\n</blockquote>\n<p><em>将username为‘jim’的age字段加5</em></p>\n<p>23、删除username为&#39;rose&#39;的数据</p>\n<blockquote>\n<p>db.mycollection.remove({uname:&#39;rose&#39;});</p>\n</blockquote>\n<p>24、集合collection重命名</p>\n<blockquote>\n<p>db.mycollection.renameCollection(&#39;c_temp&#39;);</p>\n</blockquote>\n<p><em>将mycollection集合重命名为&#39;c_temp&#39;</em>\n25、删除集合</p>\n<blockquote>\n<p>db.c_temp.drop();</p>\n</blockquote>\n<p><em>删除名为&#39;c_temp&#39;的集合</em>\n26、删除当前数据库</p>\n<blockquote>\n<p>db.dropDatabase();</p>\n</blockquote>\n<h2 id=\"-express-mongodb-\">第三部分：express 中操作mongodb数据库的一些要点</h2>\n<ul>\n<li>db.js</li>\n</ul>\n<pre><code>var settings = require(&#39;../settings.js&#39;);\nvar Db = require(&#39;mongodb&#39;).Db;\nvar Connection = require(&#39;mongodb&#39;).Connection;\nvar Server = require(&#39;mongodb&#39;).Server;\n\nmodule.exports = new Db(settings.db, new Server(settings.host, settings.port), {safe: true});\n</code></pre><ul>\n<li>user.js</li>\n</ul>\n<pre><code>var mongodb = require(&#39;./db&#39;);\nvar crypto = require(&#39;crypto&#39;);\n\nfunction User(user) {\n    this.username = user.username;\n    this.password = user.password;\n    this.email = user.email;\n}\nUser.prototype.get = function(username, callback) {\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.findOne({\n                username: username\n            }, function(err, data) {\n                if (err) {\n                    mongodb.close();\n                };\n                callback(null,data)\n            })\n        })\n    })\n}\n\nUser.prototype.save = function(callback) {\n    var user = {\n        username: this.username,\n        password: this.password,\n        email: this.email\n    };\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.insert(user, {\n                safe: true\n            }, function(err, data) {\n                mongodb.close();\n                if (err) {\n                    return callback(err);\n                };\n                callback(null, data)\n            });\n        });\n    });\n};\n\nmodule.exports = User;\n</code></pre><ul>\n<li>route.js</li>\n</ul>\n<pre><code>app.post(&#39;/signup&#39;,function(req, res){\n    var newUser = new User({\n      username: req.body.username,\n      password: req.body.password,\n      email: req.body.email\n    });\n    newUser.get(newUser.username, function(err, user){\n      if (user) {\n        res.send(user)\n      }else {\n        newUser.save(function(err, result){\n          if (err) {\n            res.send(err)\n          }else {\n            res.send(result)\n          }\n        })\n      }\n    })\n  })\n</code></pre>"}]}]