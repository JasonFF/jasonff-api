[{"title":"promise 实现 (promise implementing 翻译)","time":"2017-03-03 16:52:12","notebook":"JavaScript","_key":16,"id":"20170303","html":"<h1 id=\"promise-promise-implementing-\">promise 实现 (promise implementing 翻译)</h1>\n<h2 id=\"introduction\">Introduction</h2>\n<p>This article was originally written as an answer on <a href=\"http://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244#23785244\">Stack Overflow</a>. The hope is that by seeing how you would go about implementing <code>Promise</code>\n in JavaScript, you may gain a better understanding of how promises behave.</p>\n<h2 id=\"-\">介绍</h2>\n<p>这篇文章起初是在Stack Overflow网站里的一个回答。希望大家看完在 JavaScript 去实现 Promise 这个过程之后，可以更好地理解 promise。</p>\n<h2 id=\"state-machine\">State Machine</h2>\n<p>Since a promise is just a state machine, we should start by considering the state information we will need later.</p>\n<p>既然 promise 仅仅是一个 state machine， 我们应该先考虑待会儿要用到的 state 信息。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers attached by calling .then or .done\n  // attached 附上的\n  var handlers = [];\n}\n</code></pre>\n<h2 id=\"transitions\">Transitions</h2>\n<p>Next, lets consider the two key transitions that can occur, fulfilling and rejecting:</p>\n<p>接下来，我们就来考虑这两个关键的转换， funfilling 和 rejecting：</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n}\n</code></pre>\n<p>That gives us the basic low level transitions, but lets consider an extra, higher-level transition called <code>resolve</code>.</p>\n<p>它给了我们最基本的转换，但让我们考虑一个其他的，更高级的方法：resolve。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise() {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n\n  function resolve(result) {\n    try {\n      var then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject)\n        return\n      }\n      fulfill(result);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n</code></pre>\n<p>Note how <code>resolve</code> accepts either a promise or a plain value and if it&#39;s a promise, waits for it to complete. A promise must never be fulfilled with another promise, so it is this <code>resolve</code> function that we will expose, rather than the internal <code>fulfill</code>. We&#39;ve used a couple of helper methods, so lets define those:</p>\n<p>展示了如何 resolve 接收一个 promise 或者一个值，如果是 promise 的话，就等待它执行完在接收。 promise 必须没有被另一个promise fulfilled。所以我们才暴露这个 resolve 方法，而不是内部的fulfill。我们已经用了一些helper方法， 下面就是这些方法。</p>\n<pre><code>/**\n * Check if a value is a Promise and, if it is,\n * return the `then` method of that promise.\n * 检查是否是 Promise 如果是的话，就返回那个 promise 的 then 方法。\n *\n * @param {Promise|Any} value\n * @return {Function|Null}\n */\nfunction getThen(value) {\n  var t = typeof value;\n  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) {\n    var then = value.then;\n    if (typeof then === &#39;function&#39;) {\n      return then;\n    }\n  }\n  return null;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n *\n * @param {Function} fn A resolver function that may not be trusted\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n</code></pre><h2 id=\"constructing\">Constructing</h2>\n<p>We now have the completed internal state machine, but we have yet to expose either a method of resolving the promise or of observing it. Lets start by adding a way of resolving the promise.</p>\n<p>我们已经完成了state machine，但是我们还没暴露一个resolving方法。让我们开始添加这个方法吧。</p>\n<pre><code class=\"lang-JavaScript\">var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise(fn) {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n  }\n\n  function resolve(result) {\n    try {\n      var then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject)\n        return\n      }\n      fulfill(result);\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  doResolve(fn, resolve, reject);\n}\n</code></pre>\n<p>As you can see, we re-use <code>doResolve</code> because we have another untrusted resolver. The fn is allowed to call both <code>resolve</code> and <code>reject</code> multiple times, and even throw exceptions. It is up to us to ensure that the promise is only resolved or rejected once, and then never transitions into a different state ever again.</p>\n<p>就如你们看到的，我们复用了 doResolve 这个方法。因为我们有另外一个不确定的 resolver 。fn 方法允许调用 resolve 和 reject 方法很多次，甚至会抛出异常。 这取决于我们去保证 promise 只是被 resolve 或者 reject 一次，然后再也不会改变它的 state。</p>\n<h2 id=\"observing-via-done-\">Observing (via .done)</h2>\n<p>We now have a completed state machine, but we still have no way to observe any changes to it. Our ultimate goal is to implement <code>.then</code>, but the semantics of <code>.done</code> are much simpler so lets implement that first.</p>\n<p>Our goal here is to implement <code>promise.done(onFulfilled, onRejected)</code> such that:</p>\n<ul>\n<li>only one of <code>onFulfilled</code> or <code>onRejected</code> is called</li>\n<li>it is only called once</li>\n<li>it is never called until the next tick (i.e. after the <code>.done</code> method has returned)</li>\n<li>it is called regardless of whether the promise is resolved before or after we call <code>.done</code></li>\n</ul>\n<p>我们现在已经完成了 state machine, 但是我们还是没有方法去观察它的任何改变。我们最终的目标就是去实现 .then ，我们先实现它的话，那么 .done 将会更加容易实现。</p>\n<p>我们在这里的目标就是去实现 promise.done(onFulfilled, onRejected)\n像下面这样：</p>\n<ul>\n<li>onFulfilled 或者 onRejected 只能其中一个被调用</li>\n<li>只能被调用一次</li>\n<li>直到下一个标记才会被调用（比日说在 .done 方法被 return 了）</li>\n<li>调用的时候，不管这个 promise 是否在我们调用 .done 之前或者之后被 resolved</li>\n</ul>\n<pre><code>var PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction Promise(fn) {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  var state = PENDING;\n\n  // store value once FULFILLED or REJECTED\n  var value = null;\n\n  // store sucess &amp; failure handlers\n  var handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function resolve(result) {\n    try {\n      var then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject)\n        return\n      }\n      fulfill(result);\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  function handle(handler) {\n    if (state === PENDING) {\n      handlers.push(handler);\n    } else {\n      if (state === FULFILLED &amp;&amp;\n        typeof handler.onFulfilled === &#39;function&#39;) {\n        handler.onFulfilled(value);\n      }\n      if (state === REJECTED &amp;&amp;\n        typeof handler.onRejected === &#39;function&#39;) {\n        handler.onRejected(value);\n      }\n    }\n  }\n\n  this.done = function (onFulfilled, onRejected) {\n    // ensure we are always asynchronous\n    setTimeout(function () {\n      handle({\n        onFulfilled: onFulfilled,\n        onRejected: onRejected\n      });\n    }, 0);\n  }\n\n  doResolve(fn, resolve, reject);\n}\nWe make sure to notify the handlers when the Promise is resolved or rejected. We only ever do this in the next tick.\n\nObserving (via .then)\nNow that we have .done implemented, we can easily implement .then to just do the same thing, but construct a new Promise in the process.\n\nthis.then = function (onFulfilled, onRejected) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    return self.done(function (result) {\n      if (typeof onFulfilled === &#39;function&#39;) {\n        try {\n          return resolve(onFulfilled(result));\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return resolve(result);\n      }\n    }, function (error) {\n      if (typeof onRejected === &#39;function&#39;) {\n        try {\n          return resolve(onRejected(error));\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        return reject(error);\n      }\n    });\n  });\n}\n</code></pre><h2 id=\"further-reading\">Further Reading</h2>\n<ul>\n<li><a href=\"https://github.com/then/promise/blob/master/src/core.js\">then/promise</a> implements Promise in a very similar way.</li>\n<li><a href=\"https://github.com/kriskowal/q/blob/v1/design/README.js\">kriskowal/q</a> is a very different implementation of promises and comes with a very nice walkthrough of the design principals behind it.</li>\n<li><a href=\"https://github.com/petkaantonov/bluebird\">petkaantonov/bluebird</a> is a promise implementation that was designed exclusively for performance (along with its own esoteric helper methods). The <a href=\"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\">Optimization Killers</a> Wiki page is extremely useful for picking up tips.</li>\n<li><a href=\"http://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244#23785244\">Stack Overflow</a> is the original source of this article.</li>\n</ul>\n"},{"title":"跨域的学习","time":"2017-03-02 20:24:29","notebook":"JavaScript","_key":15,"id":"20170302","html":"<h1 id=\"-\">跨域的学习</h1>\n<h2 id=\"-\">什么是跨域？</h2>\n<blockquote>\n<p>只要协议、域名、端口有任何一个不同，都被当做是不同的域。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>url</th>\n<th>说明</th>\n<th>是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名下</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/lab/a.js\">http://www.a.com/lab/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/script/b.js\">http://www.a.com/script/b.js</a></td>\n<td>同一域名下不同文件夹</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com:8000/a.js\">http://www.a.com:8000/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名，不同端口</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.a.com/b.js\">https://www.a.com/b.js</a></td>\n<td>同一域名，不同协议</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://70.32.92.74/b.js\">http://70.32.92.74/b.js</a></td>\n<td>域名和域名对应ip</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://script.a.com/b.js\">http://script.a.com/b.js</a></td>\n<td>主域相同，子域不同</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://a.com/b.js\">http://a.com/b.js</a></td>\n<td>同一域名，不同二级域名（同上）</td>\n<td>不允许（cookie这种情况下也不允许访问）</td>\n</tr>\n<tr>\n<td><a href=\"http://www.cnblogs.com/a.js\">http://www.cnblogs.com/a.js</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>不同域名</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>对于端口和协议的不同，只能通过后台来解决。</p>\n</blockquote>\n<h2 id=\"cors-cross-origin-resource-sharing-\">CORS（Cross-origin resource sharing）跨域资源共享</h2>\n<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>\n<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>\n<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>\n<p>CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    var xhr = new XMLHttpRequest();\n    xhr.open(&quot;￼GET&quot;, &quot;/trigkit4&quot;,true);\n    xhr.send();\n&lt;/script&gt;\n</code></pre>\n<p>以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    var xhr = new XMLHttpRequest();\n    xhr.open(&quot;￼GET&quot;, &quot;http://segmentfault.com/u/trigkit4/&quot;,true);\n    xhr.send();\n&lt;/script&gt;\n</code></pre>\n<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>\n<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<h2 id=\"jsonp-json-with-padding-\">JSONP (JSON with Padding)</h2>\n<p>JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：</p>\n<pre><code class=\"lang-javascript\">callback({&quot;name&quot;,&quot;trigkit4&quot;});\n</code></pre>\n<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n&lt;/script&gt;\n&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<pre><code class=\"lang-PHP\">&lt;?php\n$callback = $_GET[&#39;callback&#39;];//得到回调函数名\n$data = array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);//要返回的数据\necho $callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;//输出\n?&gt;\n</code></pre>\n<p>最终，输出结果为：dosomething([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);</p>\n<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    $.getJSON(&#39;http://example.com/data.php?callback=?,function(jsondata)&#39;){\n        //处理获得的json数据\n    });\n&lt;/script&gt;\n</code></pre>\n<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>\n<blockquote>\n<p>JSONP的优缺点</p>\n<p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>\n<p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>\n</blockquote>\n<ul>\n<li>CORS和JSONP对比</li>\n</ul>\n<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>\n<blockquote>\n<ol>\n<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>\n</li>\n<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>\n</li>\n<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"-document-domain-\">通过修改document.domain来跨子域</h2>\n<p>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。</p>\n<p>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href=\"http://example.com/b.html\">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function test(){\n        var iframe = document.getElementById(&#39;￼ifame&#39;);\n        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n&lt;/script&gt;\n&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;\n</code></pre>\n<p>这个时候，document.domain就可以派上用场了，我们只要把<a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> 和 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> 这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>\n<ul>\n<li>在页面 <a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> 中设置document.domain:</li>\n</ul>\n<pre><code>&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    document.domain = &#39;example.com&#39;;//设置成主域\n    function test(){\n        alert(document.getElementById(&#39;￼iframe&#39;).contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n&lt;/script&gt;\n</code></pre><ul>\n<li>在页面 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> 中也设置document.domain:</li>\n</ul>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    document.domain = &#39;example.com&#39;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n&lt;/script&gt;\n</code></pre>\n<p>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h2 id=\"-window-name-\">使用window.name来进行跨域</h2>\n<p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h2 id=\"-html5-window-postmessage-\">使用HTML5的window.postMessage方法跨域</h2>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>\n<h2 id=\"-\">参考资料</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000718840\">https://segmentfault.com/a/1190000000718840</a></li>\n<li><a href=\"http://www.cnblogs.com/2050/p/3191744.html\">http://www.cnblogs.com/2050/p/3191744.html</a></li>\n<li><a href=\"https://qiutc.me/post/cross-domain-collections.html\">https://qiutc.me/post/cross-domain-collections.html</a></li>\n</ul>\n"},{"title":"fetch 学习笔记","time":"2017-03-01 14:44:12","notebook":"JavaScript","_key":14,"id":"20170301","html":"<h1 id=\"fetch-\">fetch 学习笔记</h1>\n<blockquote>\n<h3 id=\"ajax-asynchronous-javascript-and-xml-\">AJAX ( Asynchronous JavaScript and XML )</h3>\n<p>AJAX 指的是一套综合了多项技术的浏览器端网页开发技术。AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。</p>\n</blockquote>\n<h3 id=\"xmlhttprequest\">XmlHttpRequest</h3>\n<p>在大家印象中AJAX技术主要指的是XmlHttpRequest对象，它在不同浏览器中有不同的创建方法，以下是跨浏览器的通用方法：</p>\n<pre><code>// Provide the XMLHttpRequest class for IE 5.x-6.x:\n// Other browsers (including IE 7.x-8.x) ignore this\n//   when XMLHttpRequest is predefined\nvar xmlHttp;\nif (typeof XMLHttpRequest != &quot;undefined&quot;) {\n    xmlHttp = new XMLHttpRequest();\n} else if (window.ActiveXObject) {\n    var aVersions = [&quot;Msxml2.XMLHttp.5.0&quot;, &quot;Msxml2.XMLHttp.4.0&quot;, &quot;Msxml2.XMLHttp.3.0&quot;, &quot;Msxml2.XMLHttp&quot;, &quot;Microsoft.XMLHttp&quot;];\n    for (var i = 0; i &lt; aVersions.length; i++) {\n        try {\n            xmlHttp = new ActiveXObject(aVersions[i]);\n            break;\n        } catch (e) {}\n    }\n}\n</code></pre><p>它的一个基本使用方法：</p>\n<pre><code>function reqListener() {\n  const data = JSON.parse(this.responseText);\n  console.log(data)\n}\n\nfunction reqError(err) {\n  console.log(&#39;Fetch Error :-S&#39;, err)\n}\n\nconst oReq = new XMLHttpRequest();\noReq.onload = reqListener\noReq.onerror = reqError\noReq.open(&#39;get&#39;, &#39;./sample.json&#39;, true)\noReq.send()\n</code></pre><h3 id=\"jquery\">jQuery</h3>\n<pre><code>$.ajax({\n    url: &#39;./sample.json&#39;,\n    data: {\n        id: &#39;a001&#39;\n    },\n    type: &#39;GET&#39;,\n    dataType : &#39;json&#39;,\n})\n  .done(function( json ) {\n     $( &#39;&lt;h1&gt;&#39; ).text( json.title ).appendTo( &#39;body&#39; );\n     $( &#39;&lt;div class=\\&#39;content\\&#39;&gt;&#39;).html( json.html ).appendTo( &#39;body&#39; );\n  })\n  .fail(function( xhr, status, errorThrown ) {\n    console.log( &#39;出现错误!&#39; )\n    console.log( &#39;Error: &#39; + errorThrown )\n    console.log( &#39;Status: &#39; + status )\n    console.dir( xhr )\n  })\n  .always(function( xhr, status ) {\n    console.log( &#39;已完成!&#39; )\n  })\n</code></pre><h3 id=\"fetch\">fetch</h3>\n<pre><code>fetch(url).then(response =&gt; response.json())\n  .then(data =&gt; console.log(data))\n  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))\n</code></pre><ul>\n<li><h4 id=\"-fetch\">启用fetch</h4>\n</li>\n</ul>\n<p>由于目前原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ：</p>\n<blockquote>\n<p>由于 IE8 是 ES3，需要引入 ES5 的 polyfill: <a href=\"https://github.com/es-shims/es5-shim\">es5-shim, es5-sham</a></p>\n<p>引入 Promise 的 polyfill: <a href=\"https://github.com/jakearchibald/es6-promise\">es6-promise</a></p>\n<p>引入 fetch 探测库：<a href=\"https://github.com/camsong/fetch-detector\">fetch-detector</a></p>\n<p>引入 fetch 的 polyfill: <a href=\"https://github.com/camsong/fetch-ie8\">fetch-ie8</a></p>\n<p>可选：如果你还使用了 jsonp，引入 <a href=\"https://github.com/camsong/fetch-jsonp\">fetch-jsonp</a></p>\n<p>可选：开启 Babel 的 runtime 模式，现在就使用 async/await</p>\n</blockquote>\n<ul>\n<li><h3 id=\"fetch-\">fetch 常见的坑</h3>\n</li>\n<li><p>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &#39;include&#39;})</p>\n</li>\n<li><p>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</p>\n</li>\n<li><p>Fetch 和标准 Promise 的不足</p>\n</li>\n</ul>\n<blockquote>\n<p>由于 Fetch 是典型的异步场景，所以大部分遇到的问题不是 Fetch 的，其实是 Promise 的。ES6 的 Promise 是基于 Promises/A+ 标准，为了保持 简单简洁 ，只提供极简的几个 API。如果你用过一些牛 X 的异步库，如 jQuery(不要笑) 、Q.js 或者 RSVP.js，可能会感觉 Promise 功能太少了。</p>\n<ul>\n<li>没有 Deferred</li>\n</ul>\n<p>Deferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。\nECMAScript 11 年就有过 Deferred 提案，但后来没被接受。其实用 Promise 不到十行代码就能实现 Deferred：es6-deferred。现在有了 async/await，generator/yield 后，deferred 就没有使用价值了。</p>\n<ul>\n<li>没有获取状态方法：isRejected，isResolved</li>\n</ul>\n<p>标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。</p>\n<ul>\n<li>缺少其它一些方法：always，progress，finally</li>\n</ul>\n<p>always 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。</p>\n<ul>\n<li>不能中断，没有 abort、terminate、onTimeout 或 cancel 方法</li>\n</ul>\n<p>Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题 whatwg/fetch#27</p>\n</blockquote>\n<h4 id=\"-fetch-api-http-bubkoo-com-2015-05-08-introduction-to-fetch-\"><a href=\"http://bubkoo.com/2015/05/08/introduction-to-fetch/\">fetch Api 简介</a></h4>\n<h4 id=\"-\">参考资料</h4>\n<ul>\n<li><p><a href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\">https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/AJAX\">https://zh.wikipedia.org/wiki/AJAX</a></p>\n</li>\n<li><p><a href=\"http://skychang.github.io/2015/11/02/JavaScript-Use_Javascript_Fetch/\">http://skychang.github.io/2015/11/02/JavaScript-Use_Javascript_Fetch/</a></p>\n</li>\n</ul>\n"},{"title":"关于React diff的一些理解","time":"2016-12-13 09:39","notebook":"react","_key":13,"id":"20161213","html":"<h1 id=\"-react-diff-\">关于React diff的一些理解</h1>\n<p>React diff 算法，实际上解决的是将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题</p>\n<blockquote>\n<h3 id=\"diff-\">diff 策略</h3>\n<p>一、 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>\n<p>二、 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</p>\n<p>三、 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>\n</blockquote>\n<h3 id=\"tree-diff\">tree diff</h3>\n<p>tree diff 指的是在前后两个虚拟DOM树比较过程中，只对同一层进行比较，这样子明显只要遍历一遍就行了。它在操作的时候只有删除和添加。</p>\n<p>如果出现了跨层级的移动DOM，就会直接删除它在原来的位置，然后在新的位置重新创建，这样子其实影响了它的性能。所以最好不要进行跨层级移动DOM。</p>\n<h3 id=\"component-diff\">component diff</h3>\n<p>还是进行一层一层的比较。如果出现了一个节点改变了，那么它会替换这个节点和它下面的所有子节点。</p>\n<p>如果设置了shouldComponentUpdate 返回值是false，那么将认定这个节点不变，不去进行diff，节约了时间。</p>\n<h3 id=\"element-diff\">element diff</h3>\n<p>同一层级的节点比较，diff会有三个操作，添加，删除，还有移动。</p>\n<p>在同一层级的diff中会有一个问题，就是先后顺序问题，有时候，其实所有的节点都是原来的节点，只不过是修改了先后顺序而已，这个时候，diff下来肯定是很多对不上的，如果进行删除和添加操作，肯定会影响性能。</p>\n<p>这个时候，就要靠key来帮忙了。当设置了key之后，在diff过程中，会默认将同样的key的节点进行匹配diff。这样就能免去不必要的添加删除操作，只要移动就行了。</p>\n<p>diff的本质，就是通过设置一些规则，让diff算法变得快速直接。</p>\n"},{"title":"我是这样灵活控制redux的state树的","time":"2016-12-10 13:28","notebook":"react","_key":12,"id":"20161210_1","html":"<h1 id=\"-redux-state-\">我是这样灵活控制redux的state树的</h1>\n<blockquote>\n<p>在 <code>Redux</code>的操作中，做一个action往往比较麻烦，要写很多个文件。个人觉得很浪费时间，因为大部分内容只是一些机械的复制粘贴操作。</p>\n<p>所以我做了一个通用的action来非常快速和灵活的发action来改变redux的state树。</p>\n<p>说明一下，整个操作的前提是已经进行了 redux-immutable 改造。否则很难对内层的state数据进行精确操作。</p>\n<p>废话不多说了，上代码。</p>\n</blockquote>\n<ul>\n<li>action.js<blockquote>\n<p>里面已经包含了向后台请求数据的操作。</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import fetch from &#39;isomorphic-fetch&#39;;\nimport {\n    truck\n} from &#39;actions&#39;;\n\nconst BASE_URL = &quot;https://api.jasonff.top/&quot;;\n\nexport const action = ({\n    moduleName,\n    body,\n    url,\n    config,\n    method,\n    goods,\n    unload,\n    callback,\n    query,\n    deepMerge\n}) =&gt; (dispatch) =&gt; {\n\n        const resData = (json) =&gt; {\n            const data = {\n                [`${moduleName}`]: {\n                    loaded: true,\n                    ...json,\n                    ...goods\n                }\n            }\n            truck({data:data,name:`${moduleName}`,deepMerge:deepMerge})(dispatch)\n            if (callback) { // callback的存在，可以在实际使用中没必要在componentWillReceiveProps中做回调操作。可以直接对某个action做异步回调。精确，快速。\n                callback(json)\n            }\n        }\n\n        if (unload) { // unload的目的是在state树中完全卸载这条数据。\n            return truck({data:null,name:`${moduleName}`,unload:true})(dispatch)\n        }\n        if (method &amp;&amp; url) { // 发送异步请求的操作。\n            let cfg = config || {};\n            let _url = url;\n            if (query) { // 支持query操作，没有必要进行url字符串拼接了。\n                let keys;\n                _url = url + &#39;?&#39;;\n                try {\n                    keys = Object.keys(query)\n                } catch (e) {\n                    console.log(e)\n                }\n                for (var i = 0; i &lt; keys.length; i++) {\n                    _url = _url + `${keys[i]}=${query[keys[i]]}&amp;`\n                }\n                _url = _url.replace(/\\&amp;$/,&#39;&#39;)\n\n            }\n            cfg.headers = Object.assign({}, cfg.headers, {\n                &#39;Content-Type&#39;: &#39;application/json&#39;\n            })\n            fetch(BASE_URL+_url,Object.assign({},cfg,{\n                    method: method,\n                    body: JSON.stringify(body)\n            })).then(res =&gt; res.json()).then(json =&gt; resData(json)).catch(ex =&gt; resData(ex))\n        } else {\n            resData({})\n        }\n}\n</code></pre><ul>\n<li>truck.js</li>\n</ul>\n<pre><code>\nconst TRUCK_LOAD = &#39;TRUCK_LOAD&#39;;\nconst TRUCK_UNLOAD = &#39;TRUCK_UNLOAD&#39;;\nconst initialState = Immutable.Map()\n\nconst truck_load = (data,name,deepMerge) =&gt; ({\n        type: TRUCK_LOAD,\n        data: data,\n        name: name,\n        deepMerge: deepMerge\n})\n\nconst truck_unload = (data,name) =&gt; ({\n        type: TRUCK_UNLOAD,\n        name: name\n})\n\nexport default (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case &#39;TRUCK_LOAD&#39;:\n            // 下面是主要的代码来merge发上来的各个action\n            if (action.deepMerge) { // 如果是需要deepMerge的就deepMerge，这个功能可以改变state树中的深层的数据。\n                let an = Immutable.fromJS(action.data);\n                let re = state.mergeDeep(an);\n                return re;\n            }\n            // 下面的代码只merge到第二层，可以进行第二层数据上面的覆盖和替换。\n            let sn = state.get(action.name)||Immutable.Map();\n            let an = Immutable.fromJS(action.data[action.name]);\n            let nv = sn.merge(an);\n            let newAction = Immutable.Map().set(action.name, nv);\n            let re = state.merge(newAction);\n            return re;\n\n        case &#39;TRUCK_UNLOAD&#39;:\n            // 卸载掉了这条数据\n            state.delete(action.name)\n            return state\n        default:\n            return state;\n    }\n}\n\nexport const truck = ({data,name,unload,deepMerge}) =&gt; {\n    if (unload) {\n        return (dispatch)=&gt;{\n            dispatch(truck_unload(null,name))\n        }\n    }\n    return (dispatch)=&gt;{\n        dispatch(truck_load(data,name,deepMerge))\n    }\n}\n</code></pre><h3 id=\"-\">下面是我的使用示例</h3>\n<ul>\n<li>没有异步请求的情况</li>\n</ul>\n<pre><code>this.props.action({\n    moduleName: `Breadcrumb`,\n    goods: {\n        data: [{\n            url:&#39;/&#39;+selectedCity.domain,name:&#39;首页&#39;\n        },{\n            url:`/${selectedCity.domain}/buildings`,name:&#39;写字楼&#39;\n        }]\n    }\n})\n</code></pre><p><img src=\"http://api.jasonff.top/dist/20161210_1_0.png\" alt=\"Paste_Image.png\"></p>\n<ul>\n<li>有异步请求数据的情况</li>\n</ul>\n<pre><code>import React from &#39;react&#39;;\nimport {Message} from &#39;components&#39;;\nconst style = require(&#39;./Collect.scss&#39;);\n\n\nexport default ({action,status,type,id,checkLogin}) =&gt; {\n    let _status = status;\n    const ts = {\n        b: {\n            name: &#39;收藏楼盘&#39;,\n            falseurl: &#39;collections/buildings?buildingId=&#39;+id,\n            trueurl: &#39;collections/buildings?buildingId=&#39;+id,\n            param: function(_s){\n                return {\n                    moduleName: &#39;BuildingDetail&#39;,\n                    goods: {\n                        data: {\n                            collection: !_s\n                        }\n                    },\n                    deepMerge:true\n                }\n            }\n        },\n        r: {\n            name: &#39;收藏房源&#39;,\n            falseurl: &#39;collections/rooms?rooomId=&#39;+id,\n            trueurl: &#39;collections/rooms?rooomId=&#39;+id,\n        },\n        i: {\n            name: &#39;收藏众创空间&#39;,\n            falseurl: &#39;incubator/collect?incubatorId=&#39;+id,\n            trueurl: &#39;incubator/delete_collect?id=&#39;+id,\n            param: function(_s){\n                return {\n                    moduleName: &#39;IncubatorDetail&#39;,\n                    goods: {\n                        data: {\n                            collection: !_s\n                        }\n                    },\n                    deepMerge:true\n                }\n            }\n        }\n    }\n\n    const onClick = () =&gt; {\n        checkLogin()\n        .then(res=&gt;action({\n                moduleName: &quot;Collection&quot;,\n                method: `${_status?&#39;DELETE&#39;:&#39;POST&#39;}`,\n                url: ts[type][_status+&#39;url&#39;],\n                needToken: true,\n                callback: function(data) {\n                    if (data.status == 1) {\n                        try {\n                            const eR = document.getElementById(&quot;collect_e&quot;);\n                            eR.style.opacity = `${_status?1:0}`;\n                        } catch (e) {\n                            console.log(e)\n                        }\n                        try {\n                            const fR = document.getElementById(&quot;collect_f&quot;);\n                            fR.style.opacity = `${_status?0:1}`;\n                        } catch (e) {\n                            console.log(e)\n                        }\n                        Message(&#39;success&#39;,_status?&#39;取消收藏成功！&#39;:&#39;收藏成功！&#39;)\n                        action(ts[type][&quot;param&quot;](_status))\n                    }\n                }\n            })\n        )\n    }\n    return &lt;span onClick={onClick} className={style.container}&gt;\n        &lt;i id=&quot;collect_e&quot; style={{opacity:`${status?0:1}`}} className=&quot;soubanicon&quot;&gt;&lt;/i&gt;\n        &lt;i id=&quot;collect_f&quot; style={{opacity:`${status?1:0}`}} className=&quot;soubanicon&quot;&gt;&lt;/i&gt;\n        &lt;span className={style.title}&gt;{_status?&quot;已收藏&quot;:ts[type].name}&lt;/span&gt;\n    &lt;/span&gt;\n}\n</code></pre><h1 id=\"-\">最后分析一下我的这个方法吧</h1>\n<p>好处就不说了，就是非常快速灵活的发送action，想改什么就改什么。</p>\n<p>坏处：\n一、 难以设置reducer的默认值。数据结构因为太灵活不固定所以难以预测。\n二、不能对于action进行很系统的管理，只有发了之后action才看到它存在，不能在刚开始的时候就知道所有的action。其实跟第一点一样。\n三、每个action没有它们自己的设置。因为他们是被生成出来的。而不是刚开始就定义好的。\n四、其他。。。</p>\n<p>如果有什么建议，马上留言哦。谢谢您的关注。</p>\n"},{"title":"Update My Project With Immutable.js","time":"2016-12-10 10:06","notebook":"react","_key":11,"id":"20161210_0","html":"<h1 id=\"update-my-project-with-immutable-js\">Update My Project With Immutable.js</h1>\n<ul>\n<li>redux-immutable</li>\n</ul>\n<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.</p>\n<p>After that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable.</p>\n<p>Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre>"},{"title":"JavaScript some tips","time":"2016-12-07 10:15","notebook":"JavaScript","_key":10,"id":"20161207","html":"<h1 id=\"some-tips\">some tips</h1>\n<p><em>some tips about JavaScript</em></p>\n<hr>\n<h3 id=\"what-is-the-difference-between-map-every-and-foreach-\">What is the difference between .map, .every, and .forEach?</h3>\n<ul>\n<li><p>.map()</p>\n<blockquote>\n<p>returns a new Array of objects created by taking some action on the original item.</p>\n</blockquote>\n</li>\n<li><p>.every()</p>\n<blockquote>\n<p>returns a boolean - true if every element in this array satisfies the provided testing function. An important difference with .every() is that the test function may not always be called for every element in the array. Once the testing function returns false for any element, no more array elements are iterated. Therefore, the testing function should usually have no side effects.</p>\n</blockquote>\n</li>\n<li><p>.forEach()</p>\n<blockquote>\n<p>returns nothing - It iterates the Array performing a given action for each item in the Array.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"the-test-about-immutable-js\">the test about Immutable.js</h3>\n<blockquote>\n<p>It is not a very good way to add Immutable.js into a part of project.</p>\n</blockquote>\n<ul>\n<li>redux-immutable<blockquote>\n<p>Firstly, set something following the api in github <a href=\"https://github.com/gajus/redux-immutable\">redux-immutable</a>.\nAfter that I find that it is a hard task to change my existing project with immutable.js. Because the state is not an Object. The new state is a Map of Imuutable. Finally I change the <code>connect</code> function as following code.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>import {connect} from &#39;react-redux&#39;;\n\nexport default function _connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    let _mstp = function(state) {\n        const _state = state.toJS()\n        return mapStateToProps(_state)\n    }\n    return connect(_mstp,mapDispatchToProps,mergeProps,options)\n}\n</code></pre><hr>\n"},{"title":"JasonFF 静态博客的一些总结","time":"2016-11-28 20:54:12","notebook":"node","_key":9,"id":"20161127","html":"<h1 id=\"jasonff-\">JasonFF 静态博客的一些总结</h1>\n<h2 id=\"-markdown-json-\">一、将 markdown 编译为json格式</h2>\n<pre><code>var fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\nvar marked = require(&#39;marked&#39;);\nvar request = require(&#39;request&#39;);\nvar downloadPic = require(&#39;./widgets/downloadPic&#39;);\n\nfunction MarkdownReader(options) {\n    this.from = options.from;\n    this.to = options.to;\n    this.rule = /\\.md$/;\n}\n\nMarkdownReader.prototype.apply = function() {\n    var that = this;\n    try {\n        fs.readdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    } catch (e) {\n        fs.mkdirSync(path.resolve(__rootPath,&#39;./dist&#39;))\n    }\n\n    fs.readdir(that.from, function(error, files) {\n        if (error) {\n            console.error(error)\n        }\n        var mddata = new Array();\n        var notebook = new Array();\n\n        for (var i = 0; i &lt; files.length; i++) {\n            if (that.rule.test(files[i])) {\n                var article;\n                try {\n                    article = that._getArticle(files[i], i);\n                    mddata.push(article)\n                } catch (e) {\n                    console.log(e)\n                }\n\n            }\n        }\n        fs.writeFileSync(path.join(that.to, &#39;data.json&#39;), JSON.stringify(mddata.reverse()))\n        fs.writeFileSync(path.join(that.to, &#39;notebook.json&#39;), JSON.stringify(that._getNotebook(mddata)))\n    })\n}\n\n\nMarkdownReader.prototype._getArticle = function(files, index) {\n    var that = this;\n    var fileInfo;\n    var _path = path.join(that.from, files);\n    var fileText = fs.readFileSync(path.join(that.from, files)).toString()\n    var configText = fileText.substring(0, fileText.indexOf(&#39;}&#39;) + 1)\n    var markdownText = fileText.substring(fileText.indexOf(&#39;}&#39;) + 1);\n    var markdownText = this._getPic(markdownText,files)\n    var fileInfo = fs.statSync(_path)\n\n    try {\n        var config = JSON.parse(configText)\n    } catch (e) {\n        console.error(e);\n    }\n    if (!config) {\n        console.error(files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot; + files + &quot; 编译失败了！！&quot;)\n        console.log(&quot;请在 &quot; + files + &quot; 开头添加JSON格式的信息！参照栗子！请注意JSON的语法！请不要在JSON中写对象！！&quot;)\n        console.log(&quot;你看看你写的什么 &quot; + configText)\n        return false\n    }\n    config._key = index;\n    config.id = files.replace(&#39;.md&#39;, &#39;&#39;);\n    var markdownHTML = marked(markdownText);\n    config.html = markdownHTML;\n\n    return config\n}\n\nMarkdownReader.prototype._getNotebook = function(config) {\n    var result = new Array();\n    var nid = 0;\n    for (var i = 0; i &lt; config.length; i++) {\n        for (var m = 0; m &lt; result.length; m++) {\n            var ifMatch = false;\n            if (result[m].notebook == config[i].notebook) {\n                result[m].data.push(config[i]);\n                ifMatch = true;\n                break\n            }\n        }\n        if (!ifMatch) {\n            result.push({\n                nid: nid,\n                notebook: config[i].notebook,\n                data: [config[i]]\n            })\n            nid++\n        }\n    }\n    return result;\n}\n\nMarkdownReader.prototype._getPic = function(md,filename) {\n    var result,urls;\n    var _md = md;\n    try {\n        result = _md.match(/\\!\\[[^\\]]+\\]\\([^\\)]+\\)/ig)\n    } catch (e) {}\n    if (result) {\n        urls = result.map(function(item,i){\n            return /\\([^\\)]+\\)/ig.exec(item)[0].replace(/^\\(/,&#39;&#39;).replace(/\\)$/,&#39;&#39;)\n        })\n    }\n    if (urls) {\n        var basePath = path.join(__rootPath,&#39;/dist&#39;);\n        for (var i = 0; i &lt; urls.length; i++) {\n            var imgName = filename.replace(&#39;.md&#39;,&#39;&#39;)+&#39;_&#39;+i+&#39;.png&#39;;\n            downloadPic(urls[i],basePath,imgName)\n            _md = _md.replace(urls[i],&#39;http://api.jasonff.top/dist/&#39;+imgName)\n        }\n    }\n    return _md\n}\n\nmodule.exports = MarkdownReader;\n</code></pre><ul>\n<li>图片插入的解决方案\n如果按照markdown的语法进入插入图片，显得太麻烦了，人活着就是为了偷懒，怎么样才能快速将图片插入我的markdown文档中呢？\n我发现简书的插入图片特别的方便，直接在编辑器中粘贴就把图片给插入进去了。但是我的编辑环境是atom 啊。难不成自己写个atom插件？\natom插件貌似也是可行的。但是我发现一个特别偷懒的办法，我不是可以获取简书的图片地址吗？我可以把图片借助简书给下到指定文件夹。\n下面就是代码</li>\n</ul>\n<pre><code>var path = require(&#39;path&#39;);\nvar request = require(&#39;request&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar download = function(uri, dir,filename){\n    console.log(&#39;start+++&#39;+uri)\n    request.head(uri, function(err, res, body){\n        request(uri).pipe(fs.createWriteStream(dir + &quot;/&quot; + filename));\n    });\n};\n\nmodule.exports = download;\n</code></pre><blockquote>\n<p>这个就是写的下载图片到本地文件夹的一个方法。插入到markdown文件中已经在最上面的代码中体现。</p>\n</blockquote>\n<h2 id=\"-nginx-\">二、nginx 静态代理</h2>\n<p>这个时候，我已经把markdown文档转为了json格式，并且进行了编译。我把图片也已经下载到了指定的文件夹。我现在就需要将这些资源给送出去给我的前端web app。这里用依靠nginx啦！</p>\n<pre><code>server {\n    listen       80;\n    server_name  api.jasonff.top 127.0.0.1;\n\n    root /home/ubuntu/github/jasonff-api;\n\n    gzip on;\n    location ~ \\.json$ {\n        if ($request_method = &#39;OPTIONS&#39;) {\n            add_header Access-Control-Allow-Origin *;\n            add_header Access-Control-Allow-Credentials true;\n            add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n            return 200;\n        }\n\n        if ($request_method = &#39;POST&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n\n        if ($request_method = &#39;GET&#39;) {\n            add_header &#39;Access-Control-Allow-Origin&#39; *;\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\n        }\n    }\n\n}\n</code></pre><h2 id=\"-\">三、博客前端部分</h2>\n<blockquote>\n<p>前端部分没什么好说的，主要是react的一些东西。有关于react的总结，我将会有另外的笔记。</p>\n</blockquote>\n"},{"title":"linux 虚拟内存实践","time":"2016-11-16 21:41:58","notebook":"服务器","_key":8,"id":"20161116","html":"<h1 id=\"linux-\">linux 虚拟内存实践</h1>\n<ul>\n<li><p>查看 Swap 大小</p>\n<pre><code>free -m\n</code></pre></li>\n<li><p>创建一个 Swap 文件</p>\n<pre><code>mkdir swap\ncd swap\nsudo dd if=/dev/zero of=swapfile bs=1024 count=100000\n</code></pre><blockquote>\n<p>count 代表文件的大小</p>\n</blockquote>\n</li>\n<li><p>把生成的文件转换成 Swap 文件</p>\n<pre><code>sudo mkswap swapfile\n</code></pre></li>\n<li><p>激活 Swap 文件</p>\n<pre><code>sudo swapon swapfile\n</code></pre><blockquote>\n<p>再次查看 free -m 发现添加成功了</p>\n</blockquote>\n</li>\n<li><p>卸载 Swap</p>\n<pre><code>sudo swapoff swapfile\n</code></pre><blockquote>\n<p>进入刚才那个目录</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"React单页面应用项目 性能优化 实践","time":"2016-07-19 13:54:58","notebook":"react","_key":7,"id":"20160719","html":"<h1 id=\"react-\">React单页面应用项目 性能优化 实践</h1>\n<p>react 单页面应用项目在加载优化这一块就得依赖webpack的打包方式。\nwebpack的打包优化的本质就是将 bundle.js 拆分方式进行优化。</p>\n<p>目前，就我所知的 bundle.js 的拆分方式有以下几种</p>\n<blockquote>\n<ul>\n<li>按需加载\n这个方式要求在react-router中不能简单的import container，需要用到requier.ensure()方法，具体实践可以参阅相关文档，如果不用require.ensure()，webpack将不会生成很多个chunkfile，也不能实现将 bundle.js 优化的效果。下面是配置代码。</li>\n</ul>\n</blockquote>\n<pre><code>entry: {\n    main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)]\n},\noutput: {\n    path: path.resolve(__dirname, &quot;dist/app&quot;),\n    filename: &#39;bundle.[hash].js&#39;,\n    chunkFilename: &#39;[id].[hash].chunk.js&#39;,\n    publicPath: &#39;/dist/app/&#39;\n}\n</code></pre><blockquote>\n<ul>\n<li>利用webpack插件进行提取一部分内容以压缩 bundle.js\n这个方法具体用到的插件有 ExtractTextPlugin，CommonsChunkPlugin。\n同时在nginx配置中开启gzip。\n下面是配置代码</li>\n</ul>\n</blockquote>\n<pre><code>    entry: {\n      main: [path.resolve(__dirname, &#39;app/index.jsx&#39;)],\n      vendor:[&#39;react&#39;, &#39;redux&#39;] // 将一些比较大的库单独提取出来。\n    },\n    output: {\n        path: path.resolve(__dirname, &quot;dist/app&quot;),\n        filename: &#39;bundle.[hash].js&#39; // 只生成单个bundle.js文件\n    },\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n                warnings: false\n            }\n        }),\n        new ExtractTextPlugin(&#39;[name]-[chunkhash].css&#39;, {allChunks: true}), //用该插件提取所有css样式\n        new webpack.optimize.CommonsChunkPlugin(&#39;vendor&#39;,  &#39;vendor.js&#39;), //将那些库生成 vendor.js\n    ],\n    module: {\n        loaders: [\n            {\n                test: /\\.scss$/,\n                loader: ExtractTextPlugin.extract(&#39;style&#39;,&#39;css?modules&amp;importLoaders=2&amp;sourceMap&amp;localIdentName=[local]___[hash:base64:5]!sass?outputStyle=expanded&amp;sourceMap&#39;)\n            } // 将scss生成的css样式单独提取出来\n        ]\n    },\n</code></pre><blockquote>\n<ul>\n<li>还有就是上面两者的混合配置</li>\n</ul>\n</blockquote>\n<h3 id=\"-\">下面将上述的三种配置进行性能测试</h3>\n<blockquote>\n<p>测试用的是chrome的timeline，并且将项目的各项数据记录了下来</p>\n</blockquote>\n<ol>\n<li>按需加载</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_0.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>提取公共部分与css</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_1.png\" alt=\"Paste_Image.png\"></p>\n<ol>\n<li>混合模式</li>\n</ol>\n<p><img src=\"http://api.jasonff.top/dist/20160719_2.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>其实不难看出大部分的时间差异是在scripting和ldle，其他的差异都是几十毫秒而已，二这两项的差异能达到上百毫秒。</p>\n</blockquote>\n<h1 id=\"-\">总结</h1>\n<blockquote>\n<p>最后我对于项目采用何种优化方式进行一下自己的体验和总结。</p>\n<ol>\n<li>如果是小项目 bundle.js 比较小，建议使用提取公共部分与css就行。</li>\n<li>如果是大项目 bundle.js 比较大，建议使用混合模式想方设法减小bundle.js单个文件的大小。</li>\n<li>建议用sass或者less写样式，不使用内联写法，因为最后可以提取出来单独成为css。而内联写法就只能存在于bundle.js之中，增大了bundle.js。</li>\n<li>使用nginx配置，并且开启gzip。</li>\n</ol>\n</blockquote>\n"},{"title":"css3 转盘抽奖实践(sass)","time":"2016-07-07 20:29:58","notebook":"html&css","_key":6,"id":"20160707","html":"<h1 id=\"css3-sass-\">css3 转盘抽奖实践(sass)</h1>\n<blockquote>\n<p>转盘抽奖，就是像这样子的转盘。（如下图）\n点击中间的“点击抽奖”按钮，然后后面的圆形转盘开始转动，最后停在所在结果里。</p>\n</blockquote>\n<p><img src=\"http://api.jasonff.top/dist/20160707_0.png\" alt=\"Paste_Image.png\"></p>\n<h2 id=\"-\">如何实现旋转并且让指针指向目标区域？</h2>\n<blockquote>\n<p>我这里的思路是用css3的一些功能，为了能够写的便捷，我用了sass工具进行编译。</p>\n</blockquote>\n<pre><code>\n$get1: - (120deg+180deg)/2 + 5400deg;\n$get2: - (225deg+180deg)/2 + 5400deg;\n$get5: - (225deg+270deg)/2 + 5400deg;\n$get10: - (45deg+90deg)/2 + 5400deg;\n$get20: - (0deg+45deg)/2 + 5400deg;\n$get50: - (360deg+334deg)/2 + 5400deg;\n$get100: - (308deg+334deg)/2 + 5400deg;\n\n// 这里的角度，都是转盘图片中，各个区域的角度，最终将指针指向每个扇形的中心。\n// 5400deg 是转的圈数\n\n$timing: cubic-bezier(0,0,0,1);\n\n@mixin transformRotate($deg) {\n  transform:rotate($deg);\n  -ms-transform:rotate($deg); /* Internet Explorer */\n  -moz-transform:rotate($deg); /* Firefox */\n  -webkit-transform:rotate($deg); /* Safari 和 Chrome */\n  -o-transform:rotate($deg); /* Opera */\n}\n@mixin getAnimation($attribute) {\n  animation: #{$attribute};\n  -moz-animation: #{$attribute};    /* Firefox */\n  -webkit-animation: #{$attribute};    /* Safari 和 Chrome */\n  -o-animation: #{$attribute};    /* Opera */\n}\n\n@mixin keyframes($animationname, $get) {\n  @keyframes #{$animationname}\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-moz-keyframes #{$animationname} /* Firefox */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-webkit-keyframes #{$animationname} /* Safari 和 Chrome */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n  @-o-keyframes #{$animationname} /* Opera */\n  {\n    100% {\n      @include transformRotate($get);\n    }\n  }\n}\n\n@include keyframes(Kget1, $get1);\n@include keyframes(Kget2, $get2);\n@include keyframes(Kget5, $get5);\n@include keyframes(Kget10, $get10);\n@include keyframes(Kget20, $get20);\n@include keyframes(Kget50, $get50);\n@include keyframes(Kget100, $get100);\n\n.get1 {\n  @include getAnimation(&#39;Kget1 10s #{$timing} forwards&#39;);\n}\n// forwards 属性是为了在动画结束的时候不再跳回初始的状态\n.get2 {\n  @include getAnimation(&#39;Kget2 10s #{$timing} forwards&#39;);\n}\n.get5 {\n  @include getAnimation(&#39;Kget5 10s #{$timing} forwards&#39;);\n}\n.get10 {\n  @include getAnimation(&#39;Kget10 10s #{$timing} forwards&#39;);\n}\n.get20 {\n  @include getAnimation(&#39;Kget20 10s #{$timing} forwards&#39;);\n}\n.get50 {\n  @include getAnimation(&#39;Kget50 10s #{$timing} forwards&#39;);\n}\n.get100 {\n  @include getAnimation(&#39;Kget100 10s #{$timing} forwards&#39;);\n}\n</code></pre><h2 id=\"-cubic-bezier-\">下面主要对 cubic-bezier 属性进行一些注释</h2>\n<p><img src=\"http://api.jasonff.top/dist/20160707_1.png\" alt=\"Paste_Image.png\"></p>\n<blockquote>\n<p>cubic-bezier即为贝兹曲线中的绘制方法。图上有四点，P0-3，其中P0、P3是默认的点，对应了[0,0], [1,1]。而剩下的P1、P2两点则是我们通过cubic-bezier()自定义的。cubic-bezier(x1, y1, x2, y2) 为自定义，x1,x2,y1,y2的值范围在[0, 1]。\n    预留的几个特效：\n    ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)\n    linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)\n    ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)\n    ease-out: cubic-bezier(0, 0, 0.58, 1.0)\n    ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)\n也就是说第四个n是y2，和x2共同决定P2的位置</p>\n</blockquote>\n"},{"title":"react modal 的 简单实现 与 原理分析","time":"2016-06-29 16:31:30","notebook":"react","_key":5,"id":"20160629","html":"<h1 id=\"react-modal-\">react modal 的 简单实现 与 原理分析</h1>\n<blockquote>\n<p>在React项目中，由于所有的Component将会被render在body的一个div之中，并且往往是Component包Component，就像一个洋葱一样，一层包着一层，里层的很难触及比较外面的一层。</p>\n<p>可是，在css中，position属性往往被外层的position所左右，height: 100% 往往被外层的height所左右。如何才能做出一个拥有半透明的黑色遮罩，罩住整个页面，从而实现modal的效果呢？</p>\n</blockquote>\n<p>在react 中，modal 的思路就是制作一个<strong><Modal></Modal></strong> Component，但是把它render 到body 的下一层去，而不是跟其他Component 一样render 到Component 的最里层。</p>\n<p>只有render在body的下一层，与现有的Component 组平起平坐，这样才完全脱离的样式局限，当我在<strong><Modal></Modal></strong> 设置样式的时候可以为所欲为。</p>\n<p>在这里就要借助 <strong>react-dom</strong> 了。因为render方法是 <strong>react-dom</strong> 提供的；\n下面将是我测试的代码。</p>\n<pre><code>import React, {Component, PropTypes} from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\n\nexport default class Modal extends Component {\n    static defaultProps = {\n        open: false\n    };\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.open &amp;&amp; !this.props.open) { // 从无到有\n            this.node = document.createElement(&#39;div&#39;); // 创建 DOM\n            this.node.className = &#39;ReactModal&#39;; // 给上 ClassName\n            document.getElementsByTagName(&#39;body&#39;)[0].appendChild(this.node) // 给 body 加上刚才的 带有 className 的 div\n            // 这个时候创建了 render的目的地。\n            const style = require(&#39;./style.scss&#39;); // css 样式\n            const {children, ...rest} = nextProps;\n            let modal = (\n                &lt;div className={style.container}&gt;\n                    &lt;div className={style.mask} {...rest}&gt;&lt;/div&gt;\n                    {nextProps.children}\n                &lt;/div&gt;\n            );\n            // 这个时候创建了 Modal 的虚拟 Dom\n            let allClass = document.getElementsByClassName(&#39;ReactModal&#39;);\n            ReactDOM.render(modal, allClass[allClass.length - 1]) // 之所以这么写，是因为能重复打开Modal，因为每一次打开Modal，都会建立一个div\n            // 将 Modal 成功 render 到目的地\n        }\n        if (this.props.open &amp;&amp; !nextProps.open) { // 从有到无\n            ReactDOM.unmountComponentAtNode(this.node) // 调用 react-dom unmountComponentAtNode方法，将Modal解除。\n            // 或者可以写下面的方法，将整个创建的div删除，这样多次打开就不会有很多个div残留在body中，但是并不是很正规的做法。\n            // document.getElementsByTagName(&#39;body&#39;)[0].removeChild(document.getElementsByClassName(&#39;ReactModal&#39;)[0])\n        }\n    }\n    render() {\n        return null // 只要这个Component的方法，不要它的render，它的render将会render到内层。\n    }\n}\n</code></pre><p><img src=\"http://api.jasonff.top/dist/20160629_0.png\" alt=\"Paste_Image.png\"></p>\n<p>选中处为刚添加的dom，它被正确的render到body下一层，与<strong> #content </strong>平起平坐，里面有内容，上面的div为多次打开关闭Modal之后残留的div。</p>\n"},{"title":"我的mongodb操作手册","time":"2016-06-28 21:04:30","notebook":"数据库","_key":4,"id":"20160628","html":"<h1 id=\"-mongodb-\">我的mongodb操作手册</h1>\n<h2 id=\"-\">准备</h2>\n<ul>\n<li><p>下载</p>\n<pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>解压</p>\n<pre><code>tar -xvf mongodb-linux-x86_64-ubuntu1604-3.2.10.tgz\n</code></pre></li>\n<li><p>将mongodb中的bin 加入 $PATH</p>\n</li>\n</ul>\n<h2 id=\"-mongod-\">第一部分：mongod 的配置</h2>\n<blockquote>\n<p>mongod是mongodb主要的后台进程，它用来处理数据请求，管理数据存取，执行后台管理操作。在平常的使用中，一般通过一个config文件来管理数据库的行为。</p>\n</blockquote>\n<ul>\n<li>简单的配置\n<strong> myblog.conf</strong><pre><code>port = 27017\ndbpath = db\nlogpath = log/myblog.txt\nrest = true\n</code></pre></li>\n<li>启动 mongd<pre><code>sudo mongod --config myblog.conf\n</code></pre></li>\n</ul>\n<p>加入 --fork 进行后台运行</p>\n<p><em>是在那个配置文件的同一个目录中</em></p>\n<h2 id=\"-mongodb-shell-\">第二部分：mongodb shell 的命令</h2>\n<p>1、查询本地所有数据库名称        </p>\n<blockquote>\n<p>show dbs;</p>\n</blockquote>\n<p>2、切换至指定数据库环境（若无指定的数据库，则创建新的库）</p>\n<blockquote>\n<p>use mydb;</p>\n</blockquote>\n<p>3、查询当前库下的所有聚集集合collection（相当于table）</p>\n<blockquote>\n<p>show collections;</p>\n</blockquote>\n<p>4、创建聚集集合</p>\n<blockquote>\n<p>db.createCollection(&#39;mycollection&#39;);</p>\n</blockquote>\n<p> 5、查询聚集集合中数据条数</p>\n<blockquote>\n<p>db.mycollection.count();</p>\n</blockquote>\n<p>6、插入数据</p>\n<blockquote>\n<p>db.mycollection.insert({&#39;username&#39;:&#39;xyz_lmn&#39;,&#39;age&#39;:26,&#39;salary&#39;:120});</p>\n</blockquote>\n<p><em>往&#39;mycollection&#39;聚集集合中插上一条数库，name为&#39;xyz_lmn&#39;,age为&#39;26&#39;,salary为&#39;120&#39;</em></p>\n<p>7、查询age等于26的数据</p>\n<blockquote>\n<p>db.mycollection.find({&quot;age&quot;:<strong>26</strong>});</p>\n</blockquote>\n<p>8、查询salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>9、查询age小于30，salary大于100的数据</p>\n<blockquote>\n<p>db.mycollection.find({age:{$lt:<strong>30</strong>}},{salary:{$gt:<strong>100</strong>}});</p>\n</blockquote>\n<p>10、查询salary小于40或salary大于200的数据</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:200}}]});</p>\n</blockquote>\n<p>11、查询指定列的数据</p>\n<blockquote>\n<p>db.mycollection.find({},{age:<strong>1</strong>,salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>1表示显示此列的意思，也可以用true表示     12、查询username中包含&#39;e&#39;的数据</em></p>\n<blockquote>\n<p>db.mycollection.find({username:/e/});</p>\n</blockquote>\n<p>13、查询以a打头的数据</p>\n<blockquote>\n<p>db.mycollection.find({username:/^a/});</p>\n</blockquote>\n<p>14、查询age列数据，并去掉重复数据</p>\n<blockquote>\n<p>db.mycollection.distinct(&#39;age&#39;);</p>\n</blockquote>\n<p>15、查询前10条数据</p>\n<blockquote>\n<p>db.mycollection.find().limit(<strong>10</strong>);</p>\n</blockquote>\n<p>16、查询1条以后的所有数据</p>\n<blockquote>\n<p>db.mycollection.find().skip(<strong>1</strong>);</p>\n</blockquote>\n<p>17、查询第一条数据</p>\n<blockquote>\n<p>db.mycollection.findOne();</p>\n</blockquote>\n<p>18、查询结果集的记录数（查询salary小于40或大于100的记录数）</p>\n<blockquote>\n<p>db.mycollection.find({$or: [{salary: {$lt:40}}, {salary: {$gt:100}}]}).count();</p>\n</blockquote>\n<p>19、按salary升序排序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段升序排序</em>\n20、降序</p>\n<blockquote>\n<p>db.mycollection.find().sort({salary:-<strong>1</strong>});</p>\n</blockquote>\n<p><em>按照salary字段降序排序</em>\n21、根据username修改age</p>\n<blockquote>\n<p>db.employee.update({username:&#39;jim&#39;},{$set:{age:<strong>22</strong>}},false,true);</p>\n</blockquote>\n<pre><code>db.collection.update( criteria, objNew, upsert, multi )\ncriteria : update的查询条件，类似sql update查询内where后面的\nobjNew   : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\nupsert   : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\nmulti    : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n</code></pre><p>22、将指定username的age字段增加5</p>\n<blockquote>\n<p>db.mycollection.update({username:&#39;jim&#39;},{$inc:{age:<strong>5</strong>}},false,true);</p>\n</blockquote>\n<p><em>将username为‘jim’的age字段加5</em></p>\n<p>23、删除username为&#39;rose&#39;的数据</p>\n<blockquote>\n<p>db.mycollection.remove({uname:&#39;rose&#39;});</p>\n</blockquote>\n<p>24、集合collection重命名</p>\n<blockquote>\n<p>db.mycollection.renameCollection(&#39;c_temp&#39;);</p>\n</blockquote>\n<p><em>将mycollection集合重命名为&#39;c_temp&#39;</em>\n25、删除集合</p>\n<blockquote>\n<p>db.c_temp.drop();</p>\n</blockquote>\n<p><em>删除名为&#39;c_temp&#39;的集合</em>\n26、删除当前数据库</p>\n<blockquote>\n<p>db.dropDatabase();</p>\n</blockquote>\n<h2 id=\"-express-mongodb-\">第三部分：express 中操作mongodb数据库的一些要点</h2>\n<ul>\n<li>db.js</li>\n</ul>\n<pre><code>var settings = require(&#39;../settings.js&#39;);\nvar Db = require(&#39;mongodb&#39;).Db;\nvar Connection = require(&#39;mongodb&#39;).Connection;\nvar Server = require(&#39;mongodb&#39;).Server;\n\nmodule.exports = new Db(settings.db, new Server(settings.host, settings.port), {safe: true});\n</code></pre><ul>\n<li>user.js</li>\n</ul>\n<pre><code>var mongodb = require(&#39;./db&#39;);\nvar crypto = require(&#39;crypto&#39;);\n\nfunction User(user) {\n    this.username = user.username;\n    this.password = user.password;\n    this.email = user.email;\n}\nUser.prototype.get = function(username, callback) {\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.findOne({\n                username: username\n            }, function(err, data) {\n                if (err) {\n                    mongodb.close();\n                };\n                callback(null,data)\n            })\n        })\n    })\n}\n\nUser.prototype.save = function(callback) {\n    var user = {\n        username: this.username,\n        password: this.password,\n        email: this.email\n    };\n    mongodb.open(function(err, db) {\n        if (err) {\n            return callback(err);\n        };\n        db.collection(&#39;users&#39;, function(err, collection) {\n            if (err) {\n                mongodb.close();\n                return callback(err);\n            };\n            collection.insert(user, {\n                safe: true\n            }, function(err, data) {\n                mongodb.close();\n                if (err) {\n                    return callback(err);\n                };\n                callback(null, data)\n            });\n        });\n    });\n};\n\nmodule.exports = User;\n</code></pre><ul>\n<li>route.js</li>\n</ul>\n<pre><code>app.post(&#39;/signup&#39;,function(req, res){\n    var newUser = new User({\n      username: req.body.username,\n      password: req.body.password,\n      email: req.body.email\n    });\n    newUser.get(newUser.username, function(err, user){\n      if (user) {\n        res.send(user)\n      }else {\n        newUser.save(function(err, result){\n          if (err) {\n            res.send(err)\n          }else {\n            res.send(result)\n          }\n        })\n      }\n    })\n  })\n</code></pre>"},{"title":"React 静态页面 nginx 配置 小白专用","time":"2016-06-15 20:50:30","notebook":"服务器","_key":3,"id":"20160615","html":"<h1 id=\"react-nginx-\">React 静态页面 nginx 配置 小白专用</h1>\n<h3 id=\"-\">第一步：安装</h3>\n<ol>\n<li><a href=\"http://nginx.org/en/download.html\">http://nginx.org/en/download.html</a> 下载</li>\n<li><code>tar -xf nginx-1.2.0.tar.gz</code></li>\n<li>进入解压目录  <code>chmod a+rwx *</code></li>\n<li><code>./configure --without-http_rewrite_module</code></li>\n<li><code>make &amp;&amp; make install</code></li>\n<li><code>sudo /usr/local/nginx/sbin/nginx</code></li>\n<li>浏览器访问 localhost</li>\n<li>惊奇地发现欢迎页面</li>\n</ol>\n<h3 id=\"-\">第二步：基本操作</h3>\n<ul>\n<li>启动<pre><code>cd /usr/local/nginx/sbin\n./nginx\n</code></pre></li>\n<li>软链接\n启动那么麻烦，我想直接打nginx启动！<pre><code>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx\n</code></pre></li>\n<li>查看启动的配置文件\n<code>sudo nginx -t</code></li>\n<li>重启\n<code>sudo nginx -s reload</code></li>\n<li>关闭<pre><code>ps -ef | grep nginx\nkill -QUIT xxxx\n</code></pre></li>\n</ul>\n<h2 id=\"-react-nginx-\">第三步 React 静态页面 nginx 配置 简洁版</h2>\n<pre><code>worker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       8080;\n        server_name  localhost;\n\n        root /Users/jasonff/project/erp-web;\n\n        location / {\n            try_files $uri @fallback;\n        }\n\n        location @fallback {\n            rewrite .* /index.html break;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n    include servers/*;\n}\n</code></pre><h3 id=\"-\">若干解释：</h3>\n<ul>\n<li>我的配置文件在哪里？\n想知道自己的配置文件在哪里，查看第二步中的查看启动配置文件，然后将需要的配置写在这个文件里面。</li>\n</ul>\n<h2 id=\"-\">第四步：多个站点布置</h2>\n<p>在nginx.conf 文件所在目录中，新建一个文件夹 vhost ，新建若干个文件，例如 example1.conf 、 example2.conf ……</p>\n<pre><code>server {\n    listen       8030;\n    server_name  localhost;\n    root /Users/jasonff/project/souban-website;\n    location / {\n        try_files $uri @fallback;\n    }\n    location @fallback {\n        rewrite .* /index.html break;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n}\n</code></pre><p>然后重新配置nginx.conf</p>\n<pre><code>worker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    include        vhosts/*;\n    //加入include vhosts/*\n}\n</code></pre><h3 id=\"-\">附录：配置介绍（字典查询）</h3>\n<pre><code>#运行用户\nuser nobody;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes  1;\n\n#全局错误日志及PID文件\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n#工作模式及连接数上限\nevents {\n    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,\n    #仅用于linux2.6以上内核,可以大大提高nginx的性能\n    use   epoll;\n\n    #单个后台worker process进程的最大并发链接数    \n    worker_connections  1024;\n\n    # 并发总数是 worker_processes 和 worker_connections 的乘积\n    # 即 max_clients = worker_processes * worker_connections\n    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么\n    # 为什么上面反向代理要除以4，应该说是一个经验值\n    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000\n    # worker_connections 值的设置跟物理内存大小有关\n    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数\n    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右\n    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：\n    # $ cat /proc/sys/fs/file-max\n    # 输出 34336\n    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内\n    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置\n    # 使得并发总数小于操作系统可以打开的最大文件数目\n    # 其实质也就是根据主机的物理CPU和内存进行配置\n    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。\n    # ulimit -SHn 65535\n\n}\n\n\nhttp {\n    #设定mime类型,类型由mime.type文件定义\n    include    mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  logs/access.log  main;\n\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\n    #对于普通应用，必须设为 on,\n    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\n    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n    sendfile     on;\n    #tcp_nopush     on;\n\n    #连接超时时间\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    tcp_nodelay     on;\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6].&quot;;\n\n    #设定请求缓冲\n    client_header_buffer_size    128k;\n    large_client_header_buffers  4 128k;\n\n\n    #设定虚拟主机配置\n    server {\n        #侦听80端口\n        listen    80;\n        #定义使用 www.nginx.cn访问\n        server_name  www.nginx.cn;\n\n        #定义服务器的默认网站根目录位置\n        root html;\n\n        #设定本虚拟主机的访问日志\n        access_log  logs/nginx.access.log  main;\n\n        #默认请求\n        location / {\n\n            #定义首页索引文件的名称\n            index index.php index.html index.htm;  \n\n        }\n\n        # 定义错误提示页面\n        error_page   500 502 503 504 /50x.html;\n        location = /50x.html {\n        }\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n\n            #过期30天，静态文件不怎么更新，过期可以设大一点，\n            #如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        }\n\n        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\n        location ~ .php$ {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n            include fastcgi_params;\n        }\n\n        #禁止访问 .htxxx 文件\n            location ~ /.ht {\n            deny all;\n        }\n\n    }\n}\n</code></pre><p>附上我的图片</p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_0.png\" alt=\"Paste_Image.png\"></p>\n<p><img src=\"http://api.jasonff.top/dist/20160615_1.png\" alt=\"Paste_Image.png\"></p>\n"},{"title":"微信JS-SDK(express 实践)","time":"2016-06-01 15:48:30","notebook":"node","_key":2,"id":"20160601","html":"<h1 id=\"-js-sdk-express-\">微信JS-SDK(express 实践)</h1>\n<p>在这里我记录一下用node express配置微信开发的一些代码</p>\n<p>简单的三个页面</p>\n<pre><code>app.use(&#39;/&#39;, routes);\napp.use(&#39;/users&#39;, users);\napp.use(&#39;/login&#39;, login);\n</code></pre><h3 id=\"routes\">routes</h3>\n<p>这个页面我做的是 <strong>用户同意授权，获取code</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\n/* GET home page. */\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var redirect_uri = &quot;http%3A%2F%2Fwww.frombottomto.top/login&quot;;\n    var scope = &#39;snsapi_userinfo&#39;;//两种方式\n    var state = &#39;STATE&#39;;//非必须\n\n    var url = &#39;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#39;+appid+&#39;&amp;redirect_uri=&#39;+redirect_uri+&#39;&amp;response_type=code&amp;scope=&#39;+scope+&#39;&amp;state=&#39;+state+&#39;#wechat_redirect&#39;;\n    res.redirect(url);\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"login\">login</h3>\n<p>这个页面获取的是 <strong>拉取用户信息</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var code = req.query.code;\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var url = &#39;https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#39;+appid+&#39;&amp;secret=6841a50bd9b6e99c77d0e052e5e5eb2a&amp;code=&#39;+code+&#39;&amp;grant_type=authorization_code&#39;;\n\n    //获取code后，请求以下链接获取access_token：  https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code\n    //获取json后get: https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN\n\n    fetch(url).then(function(res){\n        return res.json()\n    }).then(function(json){\n        var accesstoken = json.access_token;\n        var openid = json.openid;\n        var tokenurl = &#39;https://api.weixin.qq.com/sns/userinfo?access_token=&#39;+accesstoken+&#39;&amp;openid=&#39;+openid+&#39;&amp;lang=zh_CN &#39;;\n        return fetch(tokenurl).then(function(res){\n            return res.json()\n        })\n    }).then(function(json){\n        res.send(json)\n    })\n\n});\n\nmodule.exports = router;\n</code></pre><h3 id=\"users\">users</h3>\n<p>这个页面获取的是<strong> JS-SDK的 signature</strong></p>\n<pre><code>var express = require(&#39;express&#39;);\nvar router = express.Router();\nvar fetch = require(&#39;node-fetch&#39;);\nvar sha1 = require(&#39;sha1&#39;);\n\nrouter.get(&#39;/&#39;, function(req, res, next) {\n    var appid = &#39;wx9bf16c912ddec096&#39;;\n    var secret = &#39;6841a50bd9b6e99c77d0e052e5e5eb2a&#39;;\n    var aturl = &#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#39;+appid+&#39;&amp;secret=&#39;+secret;\n    var access_token;\n\n    fetch(aturl).then(function(res){\n        return res.json()\n    }).then(function(json){\n        access_token = json.access_token;\n        var ticketurl = &#39;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&#39;+access_token+&#39;&amp;type=jsapi&#39;\n        //https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi\n\n        var jsticket;\n        fetch(ticketurl).then(function(res){\n            return res.json()\n        }).then(function(json){\n            jsticket = json.ticket;\n            console.log(req.originalUrl)\n            var string1 = &#39;jsapi_ticket=&#39;+jsticket+&#39;&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://www.frombottomto.top&#39;+req.originalUrl;\n            var signature = sha1(string1);\n            res.render(&#39;users&#39;,{signature:signature})\n        })\n\n    })\n    //https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\n});\n\nmodule.exports = router;\n</code></pre><p>另外前端渲染页面，记录的是调取微信api</p>\n<h3 id=\"users-ejs\">users.ejs</h3>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;微信js测试&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;link rel=&#39;stylesheet&#39; href=&#39;/stylesheets/style.css&#39; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;你好&lt;/h1&gt;\n    &lt;p&gt;Welcome to 微信&lt;/p&gt;\n    &lt;img src=&quot;/image/jf.png&quot; alt=&quot;&quot;&gt;\n    &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        wx.config({\n            debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n            appId: &#39;wx9bf16c912ddec096&#39;, // 必填，公众号的唯一标识\n            timestamp: 1414587457, // 必填，生成签名的时间戳\n            nonceStr: &#39;Wm3WZYTPz0wzccnW&#39;, // 必填，生成签名的随机串\n            signature: &#39;&lt;%= signature %&gt;&#39;,// 必填，签名，见附录1\n            jsApiList: [&#39;onMenuShareTimeline&#39;,&#39;onMenuShareAppMessage&#39;] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2\n        });\n        wx.ready(function(){\n            wx.onMenuShareTimeline({\n                title: &#39;JasonFF&#39;, // 分享标题\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n            wx.onMenuShareAppMessage({\n                title: &#39;JasonFF&#39;, // 分享标题\n                desc: &#39;JasonFF的主页&#39;, // 分享描述\n                link: &#39;www.google.com&#39;, // 分享链接\n                imgUrl: &#39;&#39;, // 分享图标\n                type: &#39;link&#39;, // 分享类型,music、video或link，不填默认为link\n                dataUrl: &#39;&#39;, // 如果type是music或video，则要提供数据链接，默认为空\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n        })\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"title":"react server rendering","time":"2016-05-25 17:05:30","notebook":"react","_key":1,"id":"20160525","html":"<h1 id=\"react-server-rendering-\">react server rendering（服务端渲染）</h1>\n<p><em>一个react项目在服务器端渲染，其实最本质的一个点就在于路由。路由一般采用的是<code>react-router</code>。其实在<code>react-router</code>里，它本身就提供了服务器端渲染的方法，下面对它进行一下小小的学习。</em></p>\n<p>服务端渲染跟客户端渲染有点不同，因为，服务端渲染需要发送500/30x，还要在渲染前就要请求数据。</p>\n<p><code>react-router</code>提供了两个更底层的api，一个是<code>match</code>，另一个是<code>RouterContext</code>。</p>\n<p><code>match</code>是用来匹配路由的，但是它没有渲染的功能。\n<code>RouterContext</code>用来同步渲染components的。</p>\n<p>看个例子：</p>\n<pre><code>import { renderToString } from &#39;react-dom/server&#39;\nimport { match, RouterContext } from &#39;react-router&#39;\nimport routes from &#39;./routes&#39;\nserve((req, res) =&gt; {\n    match({ routes, location: req.url }, (error, redirectLocation, renderProps) =&gt; {\n        if (error) {\n            res.status(500).send(error.message)\n        } else if (redirectLocation) {\n            res.redirect(302, redirectLocation.pathname + redirectLocation.search)\n        } else if (renderProps) {\n            res.status(200).send(renderToString(&lt;RouterContext {...renderProps} /&gt;))\n        } else {\n            res.status(404).send(&#39;Not found&#39;)\n        }\n    })\n})\n</code></pre><p>这是一个非常简单的在服务端渲染例子，但是现在一个最重要的问题，就是如何传数据呢？</p>\n<p>在react项目中，一般是用redux来进行数据的管理的。redux 里有个store维护的state状态树。那么在和api进行数据交互的时候，如何将数据放在store里面呢？</p>\n<p>基本的思路就是，在createStore的时候，将与api交互的方法同时传入进去，这样，在store中的action可以调用那个库。调用库去请求数据，一般是个promise对象，取到数据之后，然后在reducer中将数据reduce进state树中。就完成了这个过程。</p>\n<p>其实最最本质的，就是让action能去api请求数据，只要action请求到了数据并且能进入reducer，那就成功了。这个思路跟客户端渲染也没有什么区别。</p>\n<p>在服务端渲染还有一个致命的报错。来自于webpack。</p>\n<p>在client，webpack可以require()各种静态资源，但是在node 环境中,require()是只能用于javascript 的。</p>\n<p>这里就要靠一个library了。\n<a href=\"https://github.com/halt-hammerzeit/webpack-isomorphic-tools\">webpack-isomorphic-tools</a>\n具体的介绍在github中都有，也不在这里赘述。</p>\n<p>另外再向大家推荐一个完整的react例子，里面有很多很多东西可以参考借鉴，甚至可以直接拿过来做自己的项目。\n<a href=\"https://github.com/erikras/react-redux-universal-hot-example\">react栗子</a></p>\n"},{"title":"react-router 笔记","time":"2016-05-11 17:16:30","notebook":"react","_key":0,"id":"20160511","html":"<h1 id=\"react-router-\">react-router 笔记</h1>\n<h4 id=\"-hashhistory-\"><strong><code>hashHistory</code>什么用？</strong></h4>\n<p>它控制着带着hash值的路由，比如说有两个路由</p>\n<pre><code>  &lt;Router history={hashHistory}&gt;\n    &lt;Route path=&quot;/&quot; component={App}/&gt;\n    {/* add the routes here */}\n    &lt;Route path=&quot;/repos&quot; component={Repos}/&gt;\n    &lt;Route path=&quot;/about&quot; component={About}/&gt;\n  &lt;/Router&gt;\n</code></pre><p>现在去访问的话通过hash值比如\n<code>localhost:8080/#/about</code>\n<code>localhost:8080/#/repos</code>\n那我不想出现那个#呢？\n那就用<code>browserHistory</code></p>\n<h4 id=\"-link-a-\"><strong> Link 和 a 标签的区别</strong></h4>\n<p>其中一个区别是标记active。这个在导航的时候特别管用。\n以往，想要标记active需要操作dom给导航添加class或者style。\n<code>Link</code>标签提供了两个接口 <code>activeStyle</code> 和 <code>activeClassName</code> 在<code>Link</code> active的时候自动变换样式。\n<code>Link</code> 是 <code>react-router</code>内部的跳转，<code>a</code> 是浏览器的跳转。</p>\n<h4 id=\"-\"><strong>组件传参的技巧</strong></h4>\n<p>以前在传参数的时候，总会在组件中定义一些东西，比如<code>handleChange</code>、<code>handleClick</code>啊什么的。甚至在拿数据的时候还传了<code>handleRef</code>。\n现在经过观看别人的项目，我发现几个更好的解决方案。\n第一个，如何传一些<code>onChange</code>什么的参数。很简单，<code>{...this.props}</code>然后在父级的时候，传<code>onChange()</code>。传什么就进来什么，每个组件的可定义度很高。\n第二个，如何传<code>input</code>中的数据，用<code>event</code>，在<code>onChange</code>事件中，可以传<code>event</code>，然后通过<code>event.target</code>来获取<code>input</code>的DOM。so easy!</p>\n<h4 id=\"-url-\"><strong> 关于url中传参的问题</strong></h4>\n<p>比如，我想打开</p>\n<pre><code>/repos/reactjs/react-router\n/repos/facebook/react\n</code></pre><p>怎么整？\n它其实在url中传了两个参数，我们暂且定义成这样</p>\n<pre><code>/repos/:userName/:repoName\n</code></pre><p>第一、路由怎么写？</p>\n<pre><code> &lt;Route path=&quot;/repos/:userName/:repoName&quot; component={Repo}/&gt;\n</code></pre><p>第二、Link怎么写？</p>\n<pre><code> &lt;Link to=&quot;/repos/reactjs/react-router&quot;&gt;React Router&lt;/Link&gt;\n</code></pre><p>第三、如何在页面中取到参数？</p>\n<pre><code> &lt;h2&gt;{this.props.params.repoName}&lt;/h2&gt;\n</code></pre><p>这个其实还挺简单的。</p>\n<h4 id=\"-js-\"><strong>关于用js来实现页面路由跳转问题</strong></h4>\n<p>在react-router中，据我所知，有两种方法。\n第一种，使用withRouter()，然后将在内部可以获取this.props.router。\n第二种，使用this.context.router，不过在使用前必须定义这个类的contextTypes。</p>\n<p>withRouter怎么用？</p>\n<pre><code> ...\n import {withRouter} from &#39;react-router&#39;\n class Abc extends Component {\n                  ...\n       this.props.router.push(&#39;/&#39;)\n}\nexport default withRouter(Abc)\n</code></pre><p>用context怎么用？</p>\n<pre><code> ...\nexport default class Abc extends Component {\n                  ...\n       this.context.router.push(&#39;/&#39;)\n}\nAbc.contextTypes = {\n       router: React.PropsTypes.object\n}\n</code></pre>"}]